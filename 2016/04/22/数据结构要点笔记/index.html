<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="对象与指针的关系，数组的内存表示，链表，树，图，Java内置数据结构,散列的原理，set，map," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="第一章   预备知识一．对象与指针的关系
程序=数据结构+算法
一个指针只能装某一个对象的地址，不能指向两个三个或多个对象。指针可以不指向任何对象，即空指针，值为NULL。
一个对象可以有多个或零个指针指向它，如果一个对象没有任何一个指针指向它，该对象就无法访问和使用，称它为垃圾对象。

二．对象的内存表示
对象=数据+方法（逻辑上的认识）
内存中对象包含的内容(涉及到它占用多大内存的问题)类类型">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构要点笔记">
<meta property="og:url" content="http://www.guotai.cn.com/2016/04/22/数据结构要点笔记/index.html">
<meta property="og:site_name" content="苏国泰专属空间">
<meta property="og:description" content="第一章   预备知识一．对象与指针的关系
程序=数据结构+算法
一个指针只能装某一个对象的地址，不能指向两个三个或多个对象。指针可以不指向任何对象，即空指针，值为NULL。
一个对象可以有多个或零个指针指向它，如果一个对象没有任何一个指针指向它，该对象就无法访问和使用，称它为垃圾对象。

二．对象的内存表示
对象=数据+方法（逻辑上的认识）
内存中对象包含的内容(涉及到它占用多大内存的问题)类类型">
<meta property="og:updated_time" content="2016-08-22T11:54:51.839Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构要点笔记">
<meta name="twitter:description" content="第一章   预备知识一．对象与指针的关系
程序=数据结构+算法
一个指针只能装某一个对象的地址，不能指向两个三个或多个对象。指针可以不指向任何对象，即空指针，值为NULL。
一个对象可以有多个或零个指针指向它，如果一个对象没有任何一个指针指向它，该对象就无法访问和使用，称它为垃圾对象。

二．对象的内存表示
对象=数据+方法（逻辑上的认识）
内存中对象包含的内容(涉及到它占用多大内存的问题)类类型">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://www.guotai.cn.com/2016/04/22/数据结构要点笔记/"/>

  <title> 数据结构要点笔记 | 苏国泰专属空间 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">苏国泰专属空间</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">个人博客</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                数据结构要点笔记
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-22T00:00:00+08:00" content="2016-04-22">
              2016-04-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程基础/" itemprop="url" rel="index">
                    <span itemprop="name">编程基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章   预备知识"></a>第一章   预备知识</h3><h4 id="一．对象与指针的关系"><a href="#一．对象与指针的关系" class="headerlink" title="一．对象与指针的关系"></a>一．对象与指针的关系</h4><ol>
<li>程序=数据结构+算法</li>
<li>一个指针只能装某一个对象的地址，不能指向两个三个或多个对象。指针可以不指向任何对象，即空指针，值为NULL。</li>
<li>一个对象可以有多个或零个指针指向它，如果一个对象没有任何一个指针指向它，该对象就无法访问和使用，称它为垃圾对象。</li>
</ol>
<h4 id="二．对象的内存表示"><a href="#二．对象的内存表示" class="headerlink" title="二．对象的内存表示"></a>二．对象的内存表示</h4><ol>
<li>对象=数据+方法（逻辑上的认识）</li>
<li>内存中对象包含的内容(涉及到它占用多大内存的问题)<br>类类型对象：<code>(eg. int x)</code><br>静态数据区：<code>(eg. static int y)</code><br>方法区: 普通方法+静态方法</li>
<li>(继承关系中)一个对象可以被当作任何它的祖先类型来对待，正因为对象存储的这个特点，才很方便的支持了多态的效果）。</li>
</ol>
<h4 id="三．串的内存表示"><a href="#三．串的内存表示" class="headerlink" title="三．串的内存表示"></a>三．串的内存表示</h4><ol>
<li>串是Java中最常用的类，也是Java特殊对待的类型之一，另一个是数组。</li>
<li>串是定常的，它的内容一经创建就不可改变。</li>
<li>Java中(字面)常量串存储在特殊的位置：串池中，★串池的特点是不允许重复和删除它的内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">eg1. (串对象用引号括起来)</div><div class="line">String a = ”abc”</div><div class="line">String b = ”bac”</div><div class="line">//a和b这两个指针(引用)的值现在是相等的。</div><div class="line">String c = ”ab”+”c”</div><div class="line">//Java在编译时会把ab加这样的表达式直接替换为abc，所以此操作与上一句效果相同，即c指针也是指向串池中哪个唯一的abc对象。</div><div class="line">String d = new String(a)</div><div class="line">//此语句与前面都不同，它是以a为参数在堆空间中创建对象，至于它的内容与Java的实现有关。</div><div class="line">a = a+x</div><div class="line">/a指针指向新创建的串对象”abcx”,原来所指向的对象没有指针指向它变为垃圾对象，由Java回收机制回收。但请注意：串池中的x对象是不会被回收，★因为串池具有这样的特点：其中的对象没有任何指针指向它，它也不会变为垃圾对象，不会被回收。</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">eg2.</div><div class="line">//String s = “”;</div><div class="line">StringBuilder sb = new StringBuilder();</div><div class="line">For(int i =0,i&lt;100,i++)&#123;</div><div class="line">//s = s + i ;</div><div class="line">sb.append(i)</div><div class="line">&#125;</div><div class="line">String s = sb.String();</div><div class="line">System.out.prinntln(s);</div><div class="line">&#125;</div><div class="line">上述代码段中，使用StringBuilder比String效率高得多，前者只需要创建一个对象，后者中途创建很多对象浪费掉了。</div></pre></td></tr></table></figure>
<h4 id="四．数组的内存表示"><a href="#四．数组的内存表示" class="headerlink" title="四．数组的内存表示"></a>四．数组的内存表示</h4><ol>
<li>数组在Java中也是一个特殊对待的类型。一个数组中的所有元素总是要占据一片连续的内存空间。数组长度在创建以后就固定了，无法修改。（因为数组尾部可能有其它对象存储，扩展数组空间会破坏后面对象的空间）</li>
<li>数组在随机访问时速度很快，因为每个数组都占用了同样大小的内存空间，我们可方便的计算出任何一个元素在内存中的位置。然而数组结构的插入和删除操作却十分吃力的。</li>
<li>自定义My类<br><code>eg. My[ ] a = new My[5]</code><br>a指针指向数组对象，而数组中的5个元素并非是关于对象的数组， 而是关于指针的的数组，在数组中包含了5个<code>My</code>类型的指针，初始值为<code>NULL</code>,即空指针。让<code>a[1]=new My( )</code> ，这样才能够创建新的<code>My</code>类型的对象，并且把它的地址存入a1这一单元中。<br>结论：数组对象是不能够包含其它任何对象的，事实上，我们可以说任何一个对象都不能在它的内存中包含另一个对象，它充其量只能包含其它对象的指针。</li>
</ol>
<h4 id="五．多态的实现"><a href="#五．多态的实现" class="headerlink" title="五．多态的实现"></a>五．多态的实现</h4><blockquote>
<p>是面向对象的精华，它可实现抽象地概括地去编码，运行时自动去匹配的效果，符合人类思考习惯。使用多态可以降低当需求变动时我们对类必须修改的可能性。实际上Java中绝大多数方法的调用都是多态的，即Java在编译期间并不能够确定应该调用哪个方法，而是在运行时根据对象的信息来自动查找到要调用的方法。</p>
<ol>
<li>继承关系中(C类继承B类，B类继承A类)<br><code>eg. A a = new C( ) ; //指针的类型和它指向的对象的类型并不是完全一致的，称之为指针泛化。</code><br>★在A类和B类中添加f( )方法，调用<code>a.f( )</code>,</li>
</ol>
<p>如上所述，Java根据对象中提供的信息去动态的查找到某一个方法。<br>内存中的一个对象总是要有这样一个字段包含这样一个信息，它含有一个指针，该指针指向了该对象的类型信息对象。每一个类都会对应唯一的一个类型信息对象，保存了该类的很多有用信息，例如它还包含了该类的父类型信息指针。<br>所以，当我们拿到指针后，找到了对象，仍然可以判定当初创建这个对象的类型是哪一个类。通过它的类型信息指针和其父类型信息指针来自动查找到要调用的方法。我们在类型信息对象中并不会去存储方法的代码(仍存储在方法区)，仅仅是存储了方法的名字和它们的一些位置信息或一些属性信息，我们根据这些信息找到了方法的位置，仍然是去方法区执行该方法。</p>
</blockquote>
<h3 id="第二章-自定义结构"><a href="#第二章-自定义结构" class="headerlink" title="第二章   自定义结构"></a>第二章   自定义结构</h3><h4 id="一．单链表的实现"><a href="#一．单链表的实现" class="headerlink" title="一．单链表的实现"></a>一．单链表的实现</h4><ol>
<li>单链表和数组一样也是一种线性结构，它可以克服数组弱点。</li>
<li>单链表每个单元都含有两项数据，一项数据用来存储元素本身，而另一个是指针（指向与自己类似的另一个对象）。</li>
<li>链表的关键点在于每个单元并不需要连续存储，前后单元没有物理上的位置关系，内存分配比较灵活。链表的插入删除操作很方便，只需修改指针。</li>
<li>单链表的缺点是它的随机访问很慢。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">eg. 链表的使用（插入操作）：</div><div class="line">class Mylist &#123;</div><div class="line">    private int data;</div><div class="line">    private Mylist next;</div><div class="line"> </div><div class="line">    public Mylist(int x) &#123;</div><div class="line">       data = x;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void add(Mylist x) &#123;</div><div class="line">       x.next = next;</div><div class="line">       next = x;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void append(Mylist x) &#123;</div><div class="line">       Mylist p = this;</div><div class="line">       while (p.next != null) &#123;</div><div class="line">           p = p.next;</div><div class="line">       &#125;</div><div class="line">       p.next = x;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void show() &#123;</div><div class="line">       Mylist p = this;</div><div class="line">       while (p != null) &#123;</div><div class="line">           System.out.println(p.data);</div><div class="line">           p = p.next;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Test01&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">       Mylist head = new Mylist(10);</div><div class="line">       head.append(new Mylist(30));</div><div class="line">       head.append(new Mylist(40));</div><div class="line">       head.append(new Mylist(50));</div><div class="line">       head.add(new Mylist(20));</div><div class="line">       head.show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">#### 二． 双向循环链表</div><div class="line">&gt; 注：对于一个线性结构，每一个结点都有它的前驱和后继，就是说，每个单元都有两个指针，一个指向前驱，另一个指向后继，其中第一个单元的前驱和最后一个单元的后继为空指针。</div><div class="line">双向链表：为解决效率问题，在基础结点的数据结构中增加一个域（以空间换取时间效率），它的指针指向该单元的上一单元（前驱），另外一个域的指针指向后继。任给一个元素，现在可以向前也可以向后查找，更加方便快捷。</div><div class="line">(双向)循环链表：让第一个元素的前驱指向最后一个单元，让最后一个单元的后继指向第一个单元，这样便构成了循环链表，使用循环链表的好处是头尾并不特殊，这样有利于进行统一的处理。</div><div class="line"></div><div class="line">#### 三．队列与栈</div><div class="line">1. 队列与栈都是更高一层的数据结构抽象，其底层可用链表，数组或其他手段来实现，这种方式一般称它为包装类型，在设计模式中也称为门面模式（即它的功能没什么变化，只是与用户的接口形式发生了变化）。</div><div class="line">2. 栈是在一端进行操作的线性结构，而队列是在两端进行操作的线性结构，其变种分别如双栈，优先队列等.</div><div class="line">3. Java中，队列用Queen表示，它是一个接口，而栈(Stack)则表现为一个具体的类。</div><div class="line"></div><div class="line">&gt; ＊Queen接口有许多像LinkedList这样的实现类，它就是前面所说的链表的一个变种（双向循环链表）。另外，从Java API中可以看出Stack类是从Vector类继承过来的。事实上，stack类并没有实现真正的代码，它仅仅是通过Vector类实现了所有功能，然后对用户的接口做了更改，即我们前面说的门面模式。</div><div class="line">注：Vector 是Java中常用的数据结构，被称为动态数组，它有很多种方法，而Stack方法确很少，这样就简化了它对用户的接口，使我们在使用的时候站在一个更高的抽象层上。</div><div class="line"></div><div class="line">4. 作为Java开发者，我们可使用像Vector，LinkedList等这些 具体的类，而不去使用像Stack和Queen这些更高抽象层。但从设计和程序的架构角度而言，可以通过使用这些更高层次的抽象使我们的程序更加完美，更便于维护和扩展。</div><div class="line"></div><div class="line">#### 四．二叉排序树</div><div class="line">1. 内存中，链表和数组都是线性结构，实际上对象间由指针所构成的关系可以表现的更加复杂，比如说可以有分叉关系，这种分叉关系也可以大体分为两类，一类是没有循环的可以广义的称它为树，其它的称为图。</div><div class="line">2. 树的特点：从一个结点到另一个结点只有唯一的路径；图的特点：可以有多个路径，也即是存在“圈”这种特征。</div><div class="line">3. 在数据结构书上树的标准定义中，树的所有孩子是平等无区别的，所以二叉树理论上不能算作树，在这把二叉树也归为一种广义的树形结构。</div><div class="line">4. 二叉树有很多重要的用途，比如著名的哈夫曼编码树。把二叉树用于排序的应用：即二叉树排序（最多只能分两个叉，可分别称为左子树和右子树）</div><div class="line">5. 树结构本身是递归定义的，也就是说一颗树的局部仍然是一颗树，甚至可以把一个单独的节点也称为一棵树（没有孩子的特殊的树）。每棵树都有一个很特殊的节点，即根节点，只有这个节点是没有父节点的。中间节点有的有孩子有的没有孩子，这些节点称为叶子节点。</div><div class="line">6. 把树当做对象来看待，可进行多种操作，其中十分重要的一种操作是遍历操作，</div><div class="line">7. 最常用的遍历：</div><div class="line">前序遍历（先根序遍历）：根，左，右</div><div class="line">中序遍历（中根序遍历）：左，根，右</div><div class="line">8. 组成二叉树的这个节点，它的结构应当包括三个部分：一个部分用来装数据，其它两个部分是指向左子树和右子树的指针。</div></pre></td></tr></table></figure>
</li>
</ol>
<p>eg. Java代码实现二叉排序树：如12，9，5，8，15，20，把比（根）节点小的树放在左边，比其大的数放在右边。区分左右子树的比较过程中隐含的实现了数字大小排序。<br>class BiTree {/<em>定义二叉树：</em>/<br>    private int data;<br>    private BiTree left;<br>    private BiTree right;<br>    public BiTree(int x) {<br>       data = x;<br>    }<br>    public void add(BiTree x) {<br>       if (x.data &lt; this.data) { // 把x的值和目前的值进行比较<br>           if(left == null){// 如果left空閒，可以把x作為左子樹<br>              left = x;<br>           }else<br>              left.add(x);// 如果left已經被佔用了，直接把x交給left,讓它去做增加<br>       } else {<br>           if(right == null)<br>              right = x;<br>           else<br>              right.add(x);<br>           }<br>       }<br>    public void travel() {// 根據中序遍歷的規則很容易用遞歸的方式寫出<br>       if (left != null){<br>                 left.travel();}<br>       System.out.println(data);<br>       if (right != null){<br>                 right.travel();}<br>    }<br>}</p>
<p>public class Test02{/<em> 使用二叉树： </em>/<br>    public static void main(String[] args) {<br>       BiTree t = new BiTree(12);// 首先定义一个（根）节点<br>       t.add(new BiTree(9)); //通过增加节点建立二叉树,通过new BiTree(9)创建只有一个节点的树,然后把这棵树作为参数传进来<br>       t.add(new BiTree(5));<br>       t.add(new BiTree(8));<br>       t.add(new BiTree(15));<br>       t.add(new BiTree(20));<br>       t.travel();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 五．一般的树形结构</div></pre></td></tr></table></figure></p>
<p>eg. 实现一般的树形结构（有多个孩子节点）：<br>import java.util.*;<br>class MyTree{<br>    private List<node>  lst = new ArrayList<node>();//为内部类Node添加一个重要的数据成员<br>    class Node{ //内部类<br>       String data;<br>       String parent;<br>    }<br>    public void add(String parent, String child){<br>       Node t = new Node();<br>       t.data = child;<br>       t.parent = parent;<br>       lst.add(t);//把新创建的这个节点加入lst中，完成加入动作<br>    }<br>    public String getParent(String x){//查询某个节点的父节点<br>       for(int i=0; i<lst.size(); i++){="" if(lst.get(i).data.equals(x))="" return="" lst.get(i).parent;="" }="" null;="" public="" list<string=""> getChild(String x){//查询某个节点的孩子节点<br>       List<string> t = new ArrayList<string>();<br>       for(int i=0; i<lst.size(); i++){="" if(lst.get(i).parent.equals(x))="" t.add(lst.get(i).data);="" }="" return="" t;="" public="" class="" test03{="" static="" void="" main(string[]="" args)="" {="" mytree="" a="new" mytree();="" a.add("中国","北京");="" a.add("中国","河北");="" a.add("中国","江苏");="" system.out.println(a.getparent("河北"));="" system.out.println("----------");="" system.out.println(a.getchild("中国"));="" <figure=""><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#### 六．通用菜单</div><div class="line">菜单结构和树形结构有很大的相似性，可在一个菜单的结构中使用树形结构来表示它的逻辑。这里将实现的不是一般的简单的菜单，它的数据项将来是可以变化的，它可以支持任意的菜单ˎ子菜单的数据。</div></pre></td></tr></table></lst.size();></string></string></lst.size();></node></node></p>
<p>eg. （本例中直接把前面的MyTree拿过来使用，实现快捷添加）<br>import java.util.List;<br>import java.util.Scanner;</p>
<p>public class MyMenu {<br>    MyTree tree = new MyTree();<br>    public void add(String parent, String child) {<br>       tree.add(parent, child);<br>    }<br>    public String go(String x) {<br>       Scanner scan = new Scanner(System.in);<br>       for (;;) {<br>           List<string> lst = tree.getChild(x);<br>           if (lst.isEmpty()){<br>              return x;}<br>           System.out.println(“————–”);<br>           for (int i = 0; i &lt; lst.size(); i++) {<br>              System.out.println(i + “.” + lst.get(i));<br>           }<br>           System.out.println(“u. 返回上级菜单”);<br>           System.out.println(“————–”);<br>           System.out.print(“请输入选择：”);<br>           String s = scan.nextLine();<br>           if (s.equals(“u”)) {<br>              String x1 = tree.getParent(x);<br>              if (x1 != null){<br>                  x = x1;<br>              continue;}<br>           }<br>           try {<br>              String x1 = lst.get(Integer.parseInt(s));<br>              x = x1;<br>           } catch (Exception e) {<br>              System.out.println(“请从新选择！”);<br>           }<br>       }<br>    }</string></p>
<pre><code>public static void main(String[] args) {
   MyMenu m = new MyMenu();
   m.add(&quot;世界&quot;, &quot;亚洲&quot;);
   m.add(&quot;世界&quot;, &quot;欧洲&quot;);
   m.add(&quot;世界&quot;, &quot;美洲&quot;);
   m.add(&quot;亚洲&quot;, &quot;中国&quot;);
   m.add(&quot;亚洲&quot;, &quot;日本&quot;);
   m.add(&quot;亚洲&quot;, &quot;韩国&quot;);
   m.add(&quot;中国&quot;, &quot;北京&quot;);
   m.add(&quot;中国&quot;, &quot;河北&quot;);
   m.add(&quot;中国&quot;, &quot;江苏&quot;);
   String t = m.go(&quot;世界&quot;);
   System.out.println(&quot;您选择：&quot; + t);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">### 第三章   Java内置数据结构</div><div class="line">#### 一． 数组与动态数组</div><div class="line">1. Java也提供了对基本数据结构的支持，但从实用的角度出发，Java并没有提供我们前面讲的三种基本数据结构（从形态上划分为：线性结构，树形结构和图）而是代之以Se，List ，Map这三大接口。</div><div class="line">2. Java通过数组和动态数组（List家族）来进行支持线性结构。对于List而言，使用最多的实现类是Vector或者ArrayList，它们可以理解为块链结构，那就是每个单元都是数组，然后多个数组间再通过指针构成链表，这样的结构使它在访问效率上比较折中。</div><div class="line">3. List, Set,Map三者的用法以及区别：</div><div class="line">1）List和Set都是单列集合，他们有一个共同的父接口---Collection。</div><div class="line">List是依次列出一个集合中的所有的元素，允许重复，且有序；</div><div class="line">Set列出的集合元素中不允许有重复，Set中的对象不按特定方式排序（默认正向排序），</div><div class="line">但它的有些实现类能对集合中的对象按特定方式排序，例如TreeSet类，TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。</div><div class="line">￭自然排序：实现Comparable接口，重写接口中的int compareTo(Object obj)方法来比较元素之间的大小关系，然后将元素按照升序排列，该方法返回整型(-1/0/1, 小于/等于/大于)。</div><div class="line">￭定制排序：实现Comparator接口，重写接口中的int compare(Object obj1，Object obj2)方法，该方法返回整型。</div><div class="line">￭一般遍历set里面的元素时使用Iterator。</div><div class="line">2）map&lt;key,value&gt; 是一个双列集合。里面有一个key和一个value，其中value是真正存储值的变量。map存储的数据是无序的，其键（key）+不能重复，但是其值（value）是可以重复的。</div></pre></td></tr></table></figure></p>
<p>eg. 实例：java代码去掉重复语句</p>
<p>import java.util.*;<br>public class My1{<br>    public static void main(String[] args) {<br>       List<string> lst = new ArrayList<string>();<br>       lst.add(“abc”);<br>       lst.add(“xyz”);<br>       lst.add(“ttt”);<br>       lst.add(“abc”);<br>       lst.add(“dog”);<br>       lst.add(“dog”);<br>       lst.add(“dog”);<br>       lst.add(“cat”);</string></string></p>
<pre><code>   for(int i=0; i&lt;lst.size(); i++){
       int j = lst.lastIndexOf(lst.get(i));
       if(i != j) {
          lst.remove(j);
          i--; //元素循环一圈后原地不动而进行同样的动作直到没有可删除的为止
       }
   }
   System.out.println(lst);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">#### 二． Set接口与应用</div><div class="line">1. HashSet 是以一种散列表的形式来实现Set接口。</div><div class="line">2. 集合的交叉并补</div></pre></td></tr></table></figure></p>
<p>Set在Java中实际应用的例子（Java中差集的演示）：<br>eg.<br>import java.util.*;<br>public class SetTest<br>{<br>    public static void main(String[] args)<br>    {<br>       String[] a = {“zhang”,”wang”,”li”,”wu”,”han”};<br>       String[] b = {“zhang,数学,88”, “zhang,语文,89”,”zhang,英语,78”,”wu,数学,99”,”wu,英语,66”,”tang,数学,77”};</p>
<pre><code>    //求哪些同学所有科目都缺考
   Set&lt;String&gt; sa = new HashSet&lt;String&gt;();
   for(int i=0; i&lt;a.length; i++) sa.add(a[i]);
   Set&lt;String&gt; sb = new HashSet&lt;String&gt;();
   for(int i=0; i&lt;b.length; i++) sb.add(b[i].split(&quot;,&quot;)[0]);

   sa.removeAll(sb);//求差集（sa-sb）

   //集合里面的元素是没有顺序的，不能像动态数组一样去求size,然后get某一项。
   //如何取得集合中的每一个元素（即遍历集合），Java提供了一种标准手段，叫枚举或者叫迭代
   //任何实现Collection接口的这些类都会提供一个Iterator，它会返回一个Iterator接口
   Iterator&lt;String&gt; it = sa.iterator();
   while(it.hasNext()){
       System.out.println(it.next());
   }
   //System.out.println(sa);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt;&gt; 补充：★在java集合中顶层有这样两个接口Iterator和Enumeration，这两个接口是特殊的数据操作接口。Iterator用于进行数据迭代，称为迭代器；Enumeration用于进行数据枚举，称为枚举。</div><div class="line">&gt;&gt; + 枚举：</div><div class="line">该接口定义了可以对一个对象类集合中的元素进行枚举的方法，但目前已被迭代器所替代。</div><div class="line">在枚举中定义了如下两个方法：</div><div class="line">boolean hasMoreElements():判断集合中是否有元素可提取，有该方法就返回true，否则返回false</div><div class="line">Object nextElement() :将枚举中的下一个对象作为一个类属Object的引用而返回。也就是每次调用nextElement()方法获得枚举中的下一个对象。</div><div class="line">&gt;&gt; + 迭代：</div><div class="line">迭代器&lt;Iterator&gt;和枚举&lt;Enumeration&gt;的功能差不多，但在集合中推荐使用迭代器进行跌代。</div><div class="line">迭代器定义了如下三个方法：</div><div class="line">boolean hasNext():判断集合中是否有元素可迭代；</div><div class="line">E next()：返回迭代的下一个元素；</div><div class="line">Void remove():移除迭代器返回的最后一个元素。</div><div class="line"> </div><div class="line">#### 三． 散列的原理</div><div class="line">1. 散列是Hash（音译为哈希）这个外来词汇的意译。散列在现代的存储理论和数据库等领域都是十分关键的。散列的目标是已知一个关键字（在全局内是唯一的）能迅速地找到要查找的对象所在的位置。散列的基本思想是想通过某个数学公式进行计算，把关键字映射到对象存储位置信息（其空间大小往往小于关键字的可能空间）。</div><div class="line"> </div><div class="line">2. 散列特征：</div><div class="line">无视数据规模，能快速定位；</div><div class="line">会占用更大的空间；</div><div class="line">是典型的以空间换取时间；</div><div class="line">3. 散列冲突：两个不同关键字经过相同的数学变换，有时可能会碰巧得到同样的一个地址信息。它可通过各种策略来解决，其中最常用的策略就是顺序地向下去寻找。可以这样说，对象就存储在它的散列值所表达的位置的附近。</div><div class="line"></div><div class="line">#### 四． HashSet重复标准</div><div class="line">1. Set接口中并没有描述什么叫重复，什么是重复的标准，各个不同的具体实现类都会有自己的处理方法。</div><div class="line">2. HashSet是使用最多的Set类型 它判断重复的标准如下：</div><div class="line">1）HashSet先去检查了新加入对象的hashCode是否与已有的对象的hashCode发生了碰撞，如果没有碰撞，这说明必然不会重复，它就不再去调用equals方法进行比较了，否则调用equals方法，返回true才表明两个对象在内容上是真正的相同，这时候对象就被阻止在集合外面不被加进来了。（因此HashSet判断一个元素是否与集合中已有元素重复时的效率是相当高的，因为即使有很多元素，真正发生碰撞的元素毕竟是少数，如此调用equals方法的次数就很少。）</div><div class="line">2）HashSet没有办法帮助我们自定义的类型去决定什么是逻辑上的重复，因为它不知道我们是按照何种应用逻辑来决定是否重复。</div></pre></td></tr></table></figure></p>
<p>eg.  import java.util.*;<br>class Person { // 自己定义Person类<br>    private String name;<br>    private int age;<br>    public Person(String name, int age) {<br>       this.name = name;<br>       this.age = age;<br>    }<br>    public boolean equals(Object x) { //重写equals()<br>       if (x instanceof Person == false){return false;}else<br>       {Person p = (Person) x;}<br>       return this.name.equals(p.name) &amp;&amp; this.age == p.age;//只有名字和年龄都重复才叫重复<br>       // return true;<br>    }<br>    public int hashCode() {//散列码决定对象存储位置 重写hashCode()<br>       return this.name.hashCode() + this.age;<br>       // return 100;<br>    }<br>    public String toString() {//重写toString()<br>       return name + “: “ + age;<br>    }<br>}</p>
<p>public class HashSetTest {<br>    public static void main(String[] args) {<br>       Set<person> a = new HashSet<person>();<br>       a.add(new Person(“zhang”, 10));<br>       a.add(new Person(“zhang”, 11));<br>       a.add(new Person(“zhang”, 10));<br>       a.add(new Person(“li”, 10));<br>       System.out.println(a); //HashSet默认情况下认为我们这些对象都是逻辑上不重复的<br>       /*</person></person></p>
<pre><code>    * Set&lt;String&gt; a = new HashSet&lt;String&gt;();
    * a.add(&quot;abc&quot;);
    * a.add(&quot;xyz&quot;);
    * a.add(&quot;abc&quot;);//为了验证，也可改成a.add(new String(&quot;abc&quot;));
    * System.out.println(a); //结果没有输出两个adc，可见HashSet去判断对象是否重复，它用的是逻辑方式，并不是比较两个对象的地址。
    */
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#### 五．TreeSet与排序</div><div class="line">1. 根据HashCode判断重复的标准，试着去覆盖hashCode()和equals()方法，发现它们根本不起作用，这是因为TreeSet并不是用散列来进行内部对象的存储位置安排的。从名字上可感觉到它是使用了树形结构，更准确的说它是一种排序树，也就是说TreeSet要求加进来的所有元素必须都可以比较大小。而实际上并非所有元素都能够（或有必要）比较大小。</div><div class="line">2. Java支持两种标准方式：</div><div class="line">对象本身就支持一个叫Comparable的接口，任何支持了该接口的对象都实现了compareTo() 方法。（即Comparable类型的对象都有能力自己解决比较问题）</div><div class="line">对象并不需要承担比较大小的责任，而是聘请一个外来的，外部的裁判对象，来负责判定两个对象的大小关系。这种方式的优点是可以聘请不同的裁判来获得不同的比较结果。</div><div class="line">3. TreeSet如何来处理冲突问题</div></pre></td></tr></table></figure></p>
<p>eg. 实例：<br>import java.util.<em>;<br>/</em><br> //对象自身实现了Comparable接口来实现比较<br> class Person implements Comparable {<br> private String name;<br> private int age;</p>
<p> public Person(String name, int age) {<br> this.name = name;<br> this.age = age;<br> }<br> public String toString() {<br> return name + “: “ + age;<br> }<br> public int compareTo(Object x) {// 重写compareTo()方法<br> if (x instanceof Person == false) {<br> return 0;<br> } else {<br> Person p = (Person) x;<br> // return this.name.compareTo(p.name);<br> int t = this.name.compareTo(p.name);<br> if (t != 0) {<br> return t;<br> } else {<br> // return this.age - p.age;<br> return p.age - this.age;<br> }<br> }<br> }<br> */<br>// 非侵入方式：不需要对象增加一些接口或方法就让其具有比较的能力<br>class Person {<br>    private String name;<br>    private int age;<br>    public Person(String name, int age) {<br>       this.name = name;<br>       this.age = age;<br>    }<br>    public String getName() {<br>       return name;<br>    }<br>    public int getAge() {<br>       return age;<br>    }<br>    public String toString() {<br>       return name + “: “ + age;<br>    }<br>}</p>
<p>class K implements Comparator {// 新定义一个类型K（可称为裁判类(术语叫比较器)）<br>    public int compare(Object a, Object b) {// 重写compare()方法<br>       if (a instanceof Person == false || b instanceof Person == false) {<br>           return 0;<br>       } else {<br>           Person p1 = (Person) a;<br>           Person p2 = (Person) b;<br>           int t = p1.getName().compareTo(p2.getName());<br>           if (t != 0) {<br>              return t;<br>           } else {<br>              return p1.getAge() - p2.getAge();<br>//可写成return p1.getAge()-p2.getAge();按字母排序，字母相同则按年龄降序排列<br>           }<br>       }<br>    }<br>}<br>    public class TreeSetTest{<br>       public static void main(String[] args){<br>           //Set<person> a = new TreeSet<person>();<br>           Set<person> a = new TreeSet<person>(new K());<br>           a.add(new Person(“hao”, 10));<br>           a.add(new Person(“hao”, 20));<br>           a.add(new Person(“hao”, 30));<br>           a.add(new Person(“hao”, 10));<br>           a.add(new Person(“zhang”, 10));<br>           a.add(new Person(“zhang”, 11));<br>           a.add(new Person(“zhang”, 20));<br>           a.add(new Person(“li”, 40));<br>           System.out.println(a);<br>       }<br>    }</person></person></person></person></p>
<blockquote>
<p>￭注：Java中涉及到判断大小的地方很可能用的就是上述两种判断标准，如Arrays.sort(数组)，<br>Collection.sort(动态数组/list)，同样存在自定义元素比较大小问题，仍然可采用上述方案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#### 六．对象比较</div><div class="line">1. 对象的比较关系：</div><div class="line">+ 是否相等：</div><div class="line">比较指针是否指向同一个对象（==）;比较两个对象在逻辑上是否是等价的（equals()）;</div><div class="line">注：</div><div class="line">Object方法中的equals()仅仅是一个空壳，想要实现对内容的比较，需要覆盖equals()。</div><div class="line">虽然我们可以自定义比较规则，但是一般情况下要满足a.equals(a)必须返回true，即一个对象必须要和它自己逻辑等价(自反性，对称性，传递性)。</div><div class="line">在定义自己类的equals()方法时最好也能去覆盖hashCode()方法，对于equals返回是true的情况必须保证hashCode返回的值也相同。</div><div class="line">④比较相同并不能决定两个对象谁大谁小，即无法进行排序。要想实现排序必须比较出对象间更多的信息来，而不仅仅是像equals那样只返回布尔值。</div><div class="line"> </div><div class="line">+ 大小比较(a.compareTo(b)/compare(a,b))</div><div class="line">比较大小一定要返回三种信息：大于，等于，小于(Java中一般是返回一个整数（正数，0，负数）)，显然比较大小就隐含的比较了是否相等。</div><div class="line">a.compareTo(b)如果返回0，a.equals(b)就一定要返回true，这两者是相关联的。</div><div class="line"></div><div class="line">#### 七．Map接口与特性</div><div class="line">1. 类似数学中的函数概念（每一个x都有唯一的y与它对应，称y是x的函数），同样的，计算机中的函数被看成键值对，键是唯一的而值可以重复，这样从一个确定的键就可以确定出唯一的值。 Map可以看成是键值对的集合，从一个键出发可以快速的找到相应的值。</div><div class="line">2. 键和值都可以是任何一种对象，但具体的实现类却有具体的要求。</div><div class="line">3. Map的特性是一个键可以对应一个值，多个键也可以对应同一个值，但一个键绝不能对应于多个不同的值。正因为这个特性键才是不重复的。</div><div class="line">4. 把重复的键和值这种对应关系加入Map中时，后面加入的键会覆盖前面加入的键对。</div><div class="line">5. 把Map中的键值全部输出：</div><div class="line">1）调用keySet()方法取得键集（把Map转化成集合）,然后可调用iterrator()方法遍历该集合。</div><div class="line">2）调用entrySet()方法直接取出键值对。（返回的是一个内部接口类型Map.Entry&lt;string,string&gt;,也可不用泛型</div></pre></td></tr></table></figure></p>
</blockquote>
<p>eg. import java.util.*;<br>public class MyA {<br>    public static void main(String[] args) {<br>       Map<string, string="">  a = new  HashMap<string, string="">();<br>       a.put(“cat”, “猫”);<br>       a.put(“desk”, “桌子”);<br>       a.put(“table”, “桌子”);<br>       a.put(“table” ,”表格”);</string,></string,></p>
<pre><code>   System.out.println(a.get(&quot;table&quot;));

   // 遍历表格
   Set&lt;String&gt; key = a.keySet();
   Iterator&lt;String&gt; it = key.iterator();
   while(it.hasNext()){
       String s = it.next();
       System.out.println( s + &quot;----&gt;&quot; + a.get(s));
   }

   Set&lt;Map.Entry&lt;String, String&gt;&gt;  et = a.entrySet();
   Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it2 = et.iterator();
   while(it2.hasNext()){
       System.out.println(it2.next());
   }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#### 八． Map典型应用</div></pre></td></tr></table></figure></p>
<p>eg. 快速找到父节点<br>import java.util.*;<br>class MyTree{<br>    private  Map map_up = new HashMap();//子–&gt;父<br>    private Map map_down = new HashMap();//父–&gt;子（所有孩子）<br>    public void add(String parent, String child){<br>       map_up.put(child, parent);//把child作为键，parent作为值，就能表达由子到父这种联系。<br>       List lst = (List)map_down.get(parent);//把所有孩子装进一个list,再由parent指向该list,即变相表示一对一关系<br>       if(lst == null){<br>           lst = new ArrayList();<br>           map_down.put(parent, lst); //创建了键值对<br>       }<br>       lst.add(child);<br>    }<br>    public String getParent(String x)<br>    {<br>       return (String)map_up.get(x);<br>    }<br>    public List getChild(String x)<br>    {<br>       return (List)map_down.get(x);<br>    }<br>}<br>public class MyA {<br>    public static void main(String[] args){<br>       MyTree a = new MyTree();<br>       a.add(“世界”,”亚洲”);<br>       a.add(“世界”,”欧洲”);<br>       a.add(“世界”,”美洲”);<br>       a.add(“亚洲”,”中国”);<br>       a.add(“亚洲”,”韩国”);<br>       a.add(“亚洲”,”日本”);<br>       a.add(“中国”,”北京”);<br>       a.add(“中国”,”江苏”);<br>       a.add(“中国”,”山东”);<br>       a.add(“中国”,”河北”);<br>       System.out.println(a.getParent(“河北”));<br>        System.out.println(a.getChild(“中国”));<br>    }<br>}</p>
<blockquote>
<p>注：以上实例使用了Java提供的内置数据结构-Map，代码相当简洁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 第四章   排序应用</div><div class="line">#### 一．树形选择排序</div><div class="line">1. 是模拟竞标赛规则发明的。它要求待排元素的数目为2^n个，如果元素数目不够，可补充一些无用的元素来占位（比如用无穷大）。尚未排序的元素要作为叶子节点，由它们开始向上逐步的去建立二叉树。</div><div class="line">2. 要点：两两比较，输出当前的最小元素（优胜者）后，要把该元素所在叶子节点填写为无穷大，然后再把所有变动过的组重新进行比拼。</div><div class="line"></div><div class="line">#### 二．归并排序</div><div class="line">1. （merge）归并排列就是把两个已经排序好的队列合成一个有序队列。</div><div class="line">2. 建立两个指针分别指向两个已经排序了的队列的首地址，新比较两个地址的值，把小的值放入新建的队列，并移动指针继续比较。</div><div class="line"></div><div class="line">#### 三．堆排序</div><div class="line">1. 树形选择排序浪费内存，因此提出堆排序的概念。如果一颗完全二叉树的每个节点都不大于它的子节点就可以称之为堆。</div><div class="line">注：</div><div class="line">完全二叉树：除了叶子节点外所有其它节点都有完整的左子树和右子树。除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点，对于完全二叉树来说，叶子结点只可能在层次最大的两层上出现。</div><div class="line">满二叉树：除最后一层外，每一层上的所有结点都有两个子结点。在满二叉树中，每一层上的结点数都达到最大值。</div><div class="line">满二叉树肯定是完全二叉树，完全二叉树不一定是满二叉树。</div><div class="line">2. 脉络：</div><div class="line">1）先把无序待排数字填充成完全二叉树（从上到下，从左到右）；</div><div class="line">2）建堆：可从最后一个非叶子节点开始往前看；如果节点数字比其两个孩子都大，那应该和小的数字交换，不然交换后仍不满足要求；若调整后破坏原来已经满足要求的子树则继续调整。</div><div class="line">3）从初始的堆中输出堆顶的元素，根节点就空了，可把最后一个元素提拔上来让其做根元素，之后调整这个根节点。在堆排序中把这种较大元素从顶层落到底层的过程称为“筛选”。</div><div class="line">4）以同样规则重复步骤3。堆越来越小，直到整个堆只剩下一个元素，把它也输出，堆排序过程就结束了。</div><div class="line">5）原理上看堆排序可用二叉树的结构来表示，但在实际运用中可用一维数组表示这个二叉树。当然，对于一般的二叉树是不能这样表示的。现在的完全二叉树具有特殊性，我们可用数组来简单的表示它。（一维数组占内存小，完全二叉树耗内存大）</div><div class="line"></div><div class="line">#### 四．多关键字排序</div><div class="line">1. 一个对象可以用多个特征值来刻画它，可把每个特征值看成是一个关键字。如果所要求的顺序是由多个关键字联合决定，我们就可以利用这种特征来使用多关键字排序的方法。多个关键字的地位不是平等的，有一个优先级的大小。</div><div class="line">2. 模拟扑克牌排序（花色，点数...）：</div><div class="line">1）MSD: 高关键字优先</div><div class="line">2）LSD: 低关键字优先（不断分组收集）</div><div class="line">注：关键字的空间不能太大，否则分组太多，效率会很低。这种排序算法适合那种关键字很多但是每个关键字的空间又不是很大的场合。（有时如果关键字的空间太大，可以把一个关键字拆成多个小的关键字。）</div><div class="line"></div><div class="line">#### 五．链式基数排序</div><div class="line">1. 把待排序的元素用链表来存储，在分组时仅仅移动指针而不学要分配额外的空间。当然也许浪费一定空间，对每一个关键字需要分配头尾指针。</div><div class="line">2. Java中可使用现成的类来代替头尾指针，使排序的代码比较简单。</div></pre></td></tr></table></figure></p>
</blockquote>
<p>eg. 使用如LinkedList作为分组和收集里面的那个小组，它本身就具有头尾指针，无需额外定义：<br>import java.util.<em>;<br>public class MyA{<br>    public static void main(String[] args){<br>       List data = new ArrayList();<br>       //填充随机值<br>       for(int i=0; i&lt;1000; i++)<br>           data.add((int)(Math.random() </em> 10000));<br>       //准备十个桶<br>       List[] base = new ArrayList[10];<br>       for(int i=0; i<base.length; i++)="" base[i]="new" arraylist();="" 从低到高，分配与收集="" for(int="" k="1;" k<="1000;" k*="10){" i="0;" i<data.size();="" base[(integer)data.get(i)="" k%10].add(data.get(i));="" 按关键字分配到桶里="" data.clear();="" i<base.length;="" data.addall(base[i]);="" 收集,(用addall()而不用add()可把分组加进来)="" base[i].clear();="" 清桶="" }="" system.out.println(data);="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 第五章 图的应用</div><div class="line">#### 一. 图的表示</div><div class="line">1. 图是网状结构，它是数构中最复杂的元素，可以有多种表达方式，如邻接矩阵或邻接表，两种表达方式不能直观回答a是否和b连通，a到b最短路径这些问题，需由相关图的算法实现（如最短路径，最大流问题，关键路径问题，二部图问题等，这些都有了经典算法）。</div><div class="line"></div><div class="line">#### 二. 深度优先遍历</div><div class="line">1. 有些类似树的先根序遍历，不同的是，树形结构从一个节点到另一个节点只有一条路径，不会出现重复遍历的情况，而图则需对已经遍历过的节点进行标注，防止下次重复遍历。</div><div class="line">2. 深度遍历是先输出某个孩子的整个家族体系，然后才是下一个孩子的家族体系。</div></pre></td></tr></table></base.length;></p>
<p>eg1.<br>public class MyA {<br>    // 借助递归，简化代码<br>    public static void deepTravel(int[][] a, int[] color, int k) {<br>       System.out.println(k);// 通过打印它来表示遍历了K号节点<br>       color[k] = 1;// 做标记，表示该节点已经被遍历过了<br>       for (int i = 0; i &lt; a[k].length; i++) {// 遍历a的第k行的所有元素，每个元素即表示k所连接的那些顶点<br>           if (a[k][i] == 1 &amp;&amp; color[i] == 0) {// a[k][i]==1，表示二者之间存在连接，color[i]==0表示这个孩子未被标记<br>              deepTravel(a, color, i);// 递归调用<br>           }<br>       }<br>    }<br>    public static void main(String[] args) {<br>       // 需重开一个数组，记录标记信息<br>       int[][] a = {<br>// 用邻接矩阵来表示图【无向图（相互连通）矩阵是关于主对角线对称的】<br>         { 0, 1, 1, 1, 0 },<br>         { 1, 0, 1, 1, 1 },<br>         { 1, 1, 0, 0, 0 },<br>         { 1, 1, 0, 0, 0 },<br>         { 0, 1, 0, 0, 0 }<br>};<br>       int[] color = new int[a.length];<br>       deepTravel(a, color, 0);// 传入的参数分别是图，标记的数组以及开始遍历的节点<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 三． 广度优先遍历</div><div class="line">1. 适合于类似于求最短路径这样的场合，从形式上看有些类似于对树形结构进行逐层的遍历。对于图，同样需对已经遍历过的节点进行标记。</div><div class="line">2. 不同于深度遍历，先输出一个根节点的所有直接孩子，同时对已经输出的节点进行标记，防止下次再输出它，第一层输出完毕后再回来处理第二层节点，如此下去直到它们都已经被输出为止，遍历结束。</div></pre></td></tr></table></figure></p>
<p>eg1.<br>import java.util.*;<br>public class MyA {<br>    public static void main(String[] args) {<br>       // 图的邻接表定义<br>       int[][] g = {<br>              { 0, 1, 1, 0, 0, 0, 0 },<br>              { 1, 0, 0, 1, 0, 0, 1 },<br>              { 1, 0, 0, 0, 0, 1, 1 },<br>              { 0, 1, 0, 0, 1, 0, 0 },<br>              { 0, 0, 0, 1, 0, 1, 1 },<br>              { 0, 0, 1, 0, 1, 0, 0 },<br>              { 0, 1, 1, 0, 1, 0, 0 }<br>           };<br>       List lst = new ArrayList();// 等待遍历的节点<br>       Set set = new HashSet(); // 已经遍历节点的集合<br>       lst.add(0);// 加入一个初始节点</p>
<pre><code>   while (true) {
       if (lst.isEmpty()) {
          break;
       } else {
          int node = (Integer) lst.get(0);
          System.out.println(node);
          set.add(node);
          lst.remove(0);
          for (int i = 0; i &lt; g[node].length; i++) {
              //使用邻接表，next_layer.indexOf(j)&lt;0)判断i节点是否已经遍历
              if (g[node][i] == 1 &amp;&amp; set.contains(i) == false &amp;&amp; lst.indexOf(i)&lt;0){
                 lst.add(i);
              }
          }
       }
   }
}
</code></pre><p>}</p>
<pre><code>
</code></pre><p>eg2.(调用递归简化代码)<br>public class MyA{<br>    // cur_layer: 当前层<br>    static void widthTravel(int[][] g, Set tag, List cur_layer){<br>       // 遍历当前层<br>       for(int i=0; i&lt;cur_layer.size(); i++){<br>           System.out.println(cur_layer.get(i));<br>           tag.add(cur_layer.get(i));<br>       }<br>       //产生下一层<br>       List next_layer = new ArrayList();<br>       for(int i=0; i&lt;cur_layer.size(); i++){<br>           int node = (Integer)cur_layer.get(i);<br>           for(int j=0; j&lt;g[node].length; j++){<br>//使用邻接表，next_layer.indexOf(j)&lt;0)判断i节点是否已经遍历<br>              if(g[node][j]==1 &amp;&amp; next_layer.indexOf(j)&lt;0)                                                           next_layer.add(j);<br>             }<br>       }<br>       next_layer.removeAll(tag);<br>       if(next_layer.isEmpty()==false)<br>            widthTravel(g, tag, next_layer);<br>    }<br>    public static void main(String[] args){<br>       // 图的邻接表定义<br>       int[][] g = {<br>           {0,1,1,0,0,0,0},<br>           {1,0,0,1,0,0,1},<br>           {1,0,0,0,0,1,1},<br>           {0,1,0,0,1,0,0},<br>           {0,0,0,1,0,1,1},<br>           {0,0,1,0,1,0,0},<br>           {0,1,1,0,1,0,0}<br>       };<br>       Set tag = new HashSet();  //保存已经遍历的节点<br>       List layer = new ArrayList();//待遍历的节点<br>       layer.add(0);//加入一个初始节点<br>       widthTravel(g, tag, layer);<br>    }<br>}<br>``` </p>
<h4 id="四．最短路径"><a href="#四．最短路径" class="headerlink" title="四．最短路径"></a>四．最短路径</h4><h3 id="第六章-综合应用"><a href="#第六章-综合应用" class="headerlink" title="第六章 综合应用"></a>第六章 综合应用</h3>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/对象与指针的关系，数组的内存表示，链表，树，图，Java内置数据结构-散列的原理，set，map/" rel="tag">#对象与指针的关系，数组的内存表示，链表，树，图，Java内置数据结构,散列的原理，set，map</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/04/20/C语言要点笔记/" rel="next" title="C语言要点笔记">
                <i class="fa fa-chevron-left"></i> C语言要点笔记
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/04/23/Java多线程/" rel="prev" title="Java多线程">
                Java多线程 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://pan.baidu.com/s/1jIfiwwY"
               alt="sgt_tiger" />
          <p class="site-author-name" itemprop="name">sgt_tiger</p>
          <p class="site-description motion-element" itemprop="description">技术 | 生活</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一章-预备知识"><span class="nav-number">1.</span> <span class="nav-text">第一章   预备知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一．对象与指针的关系"><span class="nav-number">1.1.</span> <span class="nav-text">一．对象与指针的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二．对象的内存表示"><span class="nav-number">1.2.</span> <span class="nav-text">二．对象的内存表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三．串的内存表示"><span class="nav-number">1.3.</span> <span class="nav-text">三．串的内存表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四．数组的内存表示"><span class="nav-number">1.4.</span> <span class="nav-text">四．数组的内存表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#五．多态的实现"><span class="nav-number">1.5.</span> <span class="nav-text">五．多态的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二章-自定义结构"><span class="nav-number">2.</span> <span class="nav-text">第二章   自定义结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一．单链表的实现"><span class="nav-number">2.1.</span> <span class="nav-text">一．单链表的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#四．最短路径"><span class="nav-number">2.2.</span> <span class="nav-text">四．最短路径</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第六章-综合应用"><span class="nav-number">3.</span> <span class="nav-text">第六章 综合应用</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sgt_tiger</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
