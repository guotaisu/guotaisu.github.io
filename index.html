<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="技术 | 生活">
<meta property="og:type" content="website">
<meta property="og:title" content="苏国泰专属空间">
<meta property="og:url" content="http://www.guotai.cn.com/index.html">
<meta property="og:site_name" content="苏国泰专属空间">
<meta property="og:description" content="技术 | 生活">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="苏国泰专属空间">
<meta name="twitter:description" content="技术 | 生活">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://www.guotai.cn.com/"/>

  <title> 苏国泰专属空间 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">苏国泰专属空间</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">个人博客</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-search">
          <a href="/search" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            搜索
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/08/11/mogoroom/" itemprop="url">
                  mogoroom
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-08-11T12:00:43+08:00" content="2016-08-11">
              2016-08-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程开发/" itemprop="url" rel="index">
                    <span itemprop="name">编程开发</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<hr>
<p><strong>前端</strong></p>
<hr>
<h4 id="jsp-EL-jstl"><a href="#jsp-EL-jstl" class="headerlink" title="jsp[EL,jstl]"></a>jsp[EL,jstl]</h4><ul>
<li><p>jsp内置对象<br>Page、Request、Session、Application …</p>
</li>
<li><p>代码段</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/***计算统计周期用（Java计算时间差（年月日））**/</span></div><div class="line">public <span class="built_in">String</span> getDateDiff(<span class="built_in">Date</span> date1,<span class="built_in">Date</span> date2)&#123;</div><div class="line">    int diffYear  = getDateDiff(date1,date2,Calendar.YEAR);</div><div class="line">       int diffMonth = getDateDiff(date1,date2,Calendar.MONTH);</div><div class="line">       int diffDay   = getDateDiff(date1,date2,Calendar.DAY_OF_MONTH);</div><div class="line">       </div><div class="line">       <span class="keyword">return</span> diffYear + <span class="string">"年"</span> + diffMonth + <span class="string">"月"</span> + diffDay + <span class="string">"天"</span>;</div><div class="line">&#125;</div><div class="line">   public int getDateDiff(<span class="built_in">Date</span> date1,<span class="built_in">Date</span> date2,int diffType)&#123;</div><div class="line">       Calendar cdate1 = Calendar.getInstance();</div><div class="line">       cdate1.setTime(date1);</div><div class="line">       Calendar cdate2 = Calendar.getInstance();</div><div class="line">       cdate2.setTime(date2);</div><div class="line">       </div><div class="line">       <span class="keyword">if</span>(cdate1.getTime().getTime() - cdate2.getTime().getTime() &lt;=<span class="number">0</span> )&#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">       int year1  = cdate1.get(Calendar.YEAR);</div><div class="line">       int month1 = cdate1.get(Calendar.MONTH);</div><div class="line">       int day1   = cdate1.get(Calendar.DAY_OF_MONTH);</div><div class="line">       </div><div class="line">       int year2  = cdate2.get(Calendar.YEAR);</div><div class="line">       int month2 = cdate2.get(Calendar.MONTH);</div><div class="line">       int day2   = cdate2.get(Calendar.DAY_OF_MONTH);</div><div class="line">       </div><div class="line">       <span class="keyword">if</span>(Calendar.YEAR == diffType)&#123;<span class="comment">//计算相差的年份数据</span></div><div class="line">           <span class="keyword">if</span>(year1 - year2 &gt;= <span class="number">1</span>)&#123;</div><div class="line">               <span class="keyword">return</span> getDiffYear(year1,year2,month1,month2,day1,day2);</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Calendar.MONTH == diffType)&#123;<span class="comment">//计算相差的月份数据,除去相差的年份数据</span></div><div class="line">           int diffYear = getDateDiff(date1,date2,Calendar.YEAR);</div><div class="line">           <span class="keyword">if</span>(diffYear &gt; <span class="number">0</span>)&#123;</div><div class="line">               Calendar cdate3 = Calendar.getInstance();</div><div class="line">               cdate3.set(Calendar.YEAR, year1 + diffYear);</div><div class="line">               cdate3.set(Calendar.MONTH, month2);</div><div class="line">               cdate3.set(Calendar.DAY_OF_MONTH, day2);</div><div class="line">               </div><div class="line">               int month3 = cdate3.get(Calendar.MONTH);</div><div class="line">               int day3   = cdate3.get(Calendar.DAY_OF_MONTH);</div><div class="line">               </div><div class="line">               <span class="keyword">return</span> getDiffMonth(month1,month3,day1,day3);</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               <span class="keyword">return</span> getDiffMonth(month1,month2,day1,day2);</div><div class="line">           &#125;</div><div class="line">           </div><div class="line">       &#125;<span class="keyword">else</span> <span class="keyword">if</span>(Calendar.DAY_OF_MONTH == diffType)&#123;</div><div class="line">           int diffYear  = getDateDiff(date1,date2,Calendar.YEAR);</div><div class="line">           int diffMonth = getDateDiff(date1,date2,Calendar.MONTH);</div><div class="line">           Calendar cdate3 = Calendar.getInstance();</div><div class="line">           cdate3.set(Calendar.YEAR, year2 + diffYear);</div><div class="line">           cdate3.set(Calendar.MONTH, month2 + diffMonth);</div><div class="line">           cdate3.set(Calendar.DAY_OF_MONTH, day2);</div><div class="line">           </div><div class="line">           long diffDay = <span class="number">0</span>;</div><div class="line">           <span class="keyword">if</span>((cdate1.getTime().getTime() - cdate3.getTime().getTime())%(<span class="number">24</span> * <span class="number">3600000</span>) == <span class="number">0</span>)&#123;</div><div class="line">               diffDay = (cdate1.getTime().getTime() - cdate3.getTime().getTime())/(<span class="number">24</span> * <span class="number">3600000</span>);</div><div class="line">           &#125;<span class="keyword">else</span>&#123;</div><div class="line">               diffDay = (cdate1.getTime().getTime() - cdate3.getTime().getTime())/(<span class="number">24</span> * <span class="number">3600000</span>) + <span class="number">1</span>;</div><div class="line">           &#125;</div><div class="line">           <span class="keyword">return</span> Long.valueOf(diffDay).intValue();</div><div class="line">       &#125;<span class="keyword">else</span>&#123;</div><div class="line">           <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//金额格式化（千分位显示）</div><div class="line">var formatMoney = function(amount)&#123;</div><div class="line">	var num = parseFloat(amount).toFixed(2);</div><div class="line">	num = num.toString().replace(/\$|\,/g,&apos;&apos;); </div><div class="line">	if(isNaN(num)) num = &quot;0&quot;;</div><div class="line">	var sign = (num == (num = Math.abs(num)));</div><div class="line">	num = Math.floor(num*100+0.50000000001);</div><div class="line">	var cents = num%100;</div><div class="line">	num = Math.floor(num/100).toString();</div><div class="line">	if(cents&lt;10) cents = &quot;0&quot; + cents;</div><div class="line">	for (var i = 0; i &lt; Math.floor((num.length-(1+i))/3); i++)&#123;</div><div class="line">		num = num.substring(0,num.length-(4*i+3))+&apos;,&apos;+num.substring(num.length-(4*i+3)); </div><div class="line">	&#125;</div><div class="line">	return (((sign)?&apos;&apos;:&apos;-&apos;) + num + &apos;.&apos; + cents);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/30/OpenStack/" itemprop="url">
                  OpenStack
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-30T00:00:00+08:00" content="2016-04-30">
              2016-04-30
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/大数据与云计算/" itemprop="url" rel="index">
                    <span itemprop="name">大数据与云计算</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一章-OpenStack基础"><a href="#第一章-OpenStack基础" class="headerlink" title="第一章 OpenStack基础"></a>第一章 OpenStack基础</h2><p>1.OpenStack管理的资源及提供的服务</p>
<blockquote>
<p>OpenStack做为一个操作系统，它管理的资源主要有三个方面：计算，存储，网络。OpenStack管理这些资源并提供给上层应用或用户去使用。这些资源管理是通过OpenStack中的各个项目来实现的。其中计算资源管理相关项目是Nova；存储相关的主要有快存储服务Cinder,对象存储服务Swift和镜像存储服务Glance；与网络相关的主要是一个和软件定义网络相关的项目Neutron(原名叫Qauntum)。另外Nova中有一个管理网络的模块叫做Nova Network，它做为一个比较稳定的遗留组件，现在仍然在OpenStack里和Neutron并存，在小规模部署里面，为了追求稳定和减少工作量会去使用它对网络资源进行管理。</p>
<ul>
<li>附:OpenStack资源VS公有云资源:<br><img src="./images/OpenStack%20VS%20%E5%85%AC%E6%9C%89%E4%BA%91.jpg" alt="enter description here" title="OpenStack VS 公有云.jpg"></li>
</ul>
</blockquote>
<p>3.OpenStack基本组件</p>
<ul>
<li>Nova（OpenStack Compute）:<br>它是OpenStack里最核心的项目， 主要作用是控制虚拟机的创建以及改变他的容量和配置；它还可以做虚拟机的销毁，即虚拟机的整个生命周期都是由Nova来控制的。Nova的部署和运行一般有两种情况：一种是作为Controller节点去运行，它的核心部分主要有Scheduler(决定将要启动的虚拟机调度到哪个物理节点上),Conductor(对所有的计算节点进行统一管理)，NovaCell(级联)，用这些来控制其它一些运算节点。另外一种是作为Compute节点运行，它的核心部分是Nova  Compute，用来控制运行实际的虚拟机。</li>
<li>Cinder:<br>它主要用途是用来提供块存储服务。它最核心的两个部分是Scheduler和Cinder Volume。此处Scheduler的功能和Nova的Scheduler功能接近，用来决定通过哪个Cinder Volume进行读取操作。而Cinder Volume是实际控制存储设备的节点。</li>
<li>Neutron<br>它是当下流行的SDN(软件定义网络)在OpenStack里的一个实现。Neutron有一个很大特点就是它提供了Plugin组件/模块（用户可以自定义）。</li>
<li>Swift<br>相对独立的一个组件，它和其他组件的交互关系比较少。它提供对象存储服务，类似于亚马逊S3或者国内七牛这样一个存储服务。</li>
<li>Glance<br>它是OpenStack里面使用Swift最多的组件，它主要是用Swift来存储虚拟机的镜像和快照等。</li>
<li>Keystone<br>它主要是为各个组件提供用户的认证，建权等服务。</li>
<li>Horizon<br>它是一个图形界面。</li>
<li>其它组件<br>Heat:  用来做各个服务的编排。<br>Sahara:  使Hadoop能够在OpenStack上运行。<br>……</li>
</ul>
<h2 id="第二章-OpenStack架构分析"><a href="#第二章-OpenStack架构分析" class="headerlink" title="第二章 OpenStack架构分析"></a>第二章 OpenStack架构分析</h2><p>1.OpenStack组件间的逻辑关系<br>以E版本为例，含七大基本组件：<br>Dashboard(即Horizon)；Identity(即keystone)compute(即Nova)；Image(即Glance)；Object Storage(即Swift)；Network(即Neutron)；Block Storage(即Clinder)；</p>
<blockquote>
<p>注：其中Network(即Neutron)和Block Storage(即Clinder)分别是从Compute Network和Compute<br>Vloume发展出来的。但Network组件并没有直接去替换Compute Network，它是相对独立的（也是当下流行的SDN）的一个项目，它为Compute提供网络连接，提供网络资源管理这些服务。而Block Storage则替换了Compute Vloume，它为Compute提供块存储服务。</p>
</blockquote>
<p>2.OpenStack的API</p>
<ul>
<li>OpenStack各组件间通过相互调用API实现通信。OpenStack的API是基于HTTP协议的RESTful Web API。（REST:表现状态传输 VS另外一种Web服务接口协议：SOAP）</li>
<li>REST架构里对资源的操作包括获取，创建，修改和删除。正好对应HTTP里提供的GET,POST,PUT,DELETE方法。所以用HTTP来实现REST是比较方便的。</li>
<li>RESTful Web API主要有以下三个要点：<br>①资源地址（即资源的URI）：如以http开头的地址<br>②传输资源的表现形式(即Web服务接受与返回的互联网媒体类型）:JSON, XML等。<br>③对资源的操作(即Web服务在该资源上所支持的一系列请求方法)：如GET,POST,PUT或DELETE</li>
<li>调用及调试API的方式<br>①curl命令：linux下发送http请求并接受响应的命令行工具<br>②OpenStack命令行客户端：python写的命令行客户端<br>③FireFox或Chrome浏览器的REST客户端：图形界面<br>④OpenStack的SDK： 不要手写代码发送HTTP请求调用REST接口，省去一些诸如Token等数据的管理工作，能够很方便地基于OpenStack做开发。</li>
</ul>
<p>3.OpenStack组件间的通信关系<br>OpenStack组件间的通信关系分为四类：</p>
<ul>
<li>基于HTTP协议的通信<br>①出现在各个组件API之间的调用。最常见的是通过Horizon(或说命令行接口)对各组件进行操作的时候产生的通信；另外就是各组件通过Keystone对用户身份进行校验的时候产生的通信；还有就是Nova Compute在获取镜像的时候对Glance API的调用及Swift数据的读写也是通过HTTP协议的RESTful Web API来进行的。</li>
<li>基于(消息队列)AMQP协议的通信<br>①主要是每个项目内部各个组件之间的通信。例如Nova的Nova  Compute和Scheduler之间及Scheduler和Cinder Volume之间。（注意：由于Cinder是从Nova Volume演化出来的，所以Cinder和Nova之间也有通过AMQP协议通信的关系）<br>②AMQP协议进行通信也属于面向服务的架构，所以虽然大部分通过AMQP协议进行通信的组件属于同一个项目，但是并不要求它们安装部署在同一个节点上。如Nova Compute 和Nova Conductor反而反而通常要求它们不能部署在同一个节点上；而实际上Nova Conductor和Nova Scheduler也可以放到不同的节点上，这有利于系统的横向扩展，我们可对其中的各个组件分别按照它们的负载情况进行横向扩展。（用不同数量的节点去承载它们这些服务）<br>③OpenStack并没有规定AMQP协议的实现，我们经常使用的是private MQ，实际用户可根据自身情况选择其它的消息中间件。</li>
<li>基于数据库连接的通信（主要是SQL）<br>①出现在各个组件和数据库之间，这些通信大多也属于项目内部，和前面基AMQP的类似。它也不要求数据库和项目其它组件安装在同一个节点上，它也可以分开安装，甚至我们还可专门部署这个数据库服务器，把这些数据库服务放在上面，然后之间是通过基于SQL的这些连接来进行通信。<br>②OpenStack同样没有规定必须使用哪种数据库，我们通常使用的是MySQL，实际用户可根据自身情况选择其它的数据库。</li>
<li>基于第三方API（或称为Native API）进行通信<br>①出现在各OpenStack各组件和第三方的软件或硬件之间。如Cinder和存储后端设备之间的通信；又如Neutron的agent(或者说插件)和网络设备之间的通信。这些通信都需要调用第三方设备或第三方软件的API（Native API）。</li>
</ul>
<p>4.OpenStack中几种不同的存储<br>OpenStack的三种存储服务：Glance,Swift,Cinder</p>
<ul>
<li>①Glance(镜像存储): 一个镜像管理服务，本身不具备存储功能，它的后端可以接其它的存储系统，可以是存储设备，本地存储，Swift，也可以是亚马逊S3等。</li>
</ul>
<blockquote>
<p>附:三种存储概念：</p>
<ul>
<li>文件系统：（有POSIX接口）如Glance里的GFS，Hadoop里的HDFS</li>
<li>块存储：如EMC设备，华为的SAN设备，NetApp；“散存储”一般都提供块存储。<br>对应Cinder，其实Cinder本身也并不是提供数据存储的，它也需要接一个存储的后端，即EMC的散设备等，及最新流行的开源的分布式存储Ceph(可提供块存储服务)。</li>
<li>对象存储：对应Swift，典型代表如亚马逊的AWS S3。它是通过RESTful Web API去访问的，它的优势在于可以很方便地去访问存储的数据。</li>
</ul>
</blockquote>
<ul>
<li>②Cinder<br>给OpenStack提供块存储的接口。它有一个很重要的功能叫卷管理功能。虚拟机并不直接去使用存储设备（或使用后端的存储系统），它使用的是虚拟机上的块设备，可称为卷(Volume），实际上Cinder就是去创建和管理这些Volume，并且把它挂载到虚拟机上。</li>
<li>③Swift<br>提供对象存储服务。如果使用文件系统，当数据量特别大的时候，存储性能会急剧下降。而对象存储抛弃了目录树的结构，用一种扁平化的结构去管理数据。实际上Swift只有三层结构：Account(关联账户), Container(容器，对Object分类), Object (最终的数据/即文件)。</li>
</ul>
<p>5.OpenStack工作流程<br>OpenStack工作流程 相当复杂（有五十多个步骤）。虚拟机创建的四个阶段  :<br>scheduling , networking , block_device_mapping, spawing</p>
<p>6.OpenStack的部署架构</p>
<ul>
<li>OpenStack各个项目，组件按一定方式安装到实际的服务器节点上，实际的存储设备上，然后通过网络把它们连接起来，这就是OpenStack的部署架构。</li>
<li>OpenStack部署分为单节点部署和多节点部署（集群部署）</li>
<li>OpenStack的部署架构不是一层不变的，而是根据实际需求设计不同的实施方案。</li>
<li>OpenStack的简单部署架构：</li>
</ul>
<blockquote>
<p>附：</p>
<ul>
<li>三种网络：<br>①(绿色)管理网络：OpenStack的管理节点(或管理服务)对其它的节点进行管理的网络。它们之间有如不同组件之间的API调用，虚拟机之间的迁移等<br>②（蓝色）存储网络：是计算节点，访问存储服务的网络。包括向存储设备里读写数据的流量基本上都需要从存储网络走。<br>③（黄色）服务网络：是由OpenStack去管理的这些虚拟机对外提供服务的网络。</li>
<li>四种节点：<br>①控制节点：是OpenStack的管理节点，先前介绍的OpenStack大部分服务都是运行在控制节点上。如keystone认证服务，Glance管理服务等。<br>注： 特别的，Nova和Neutron这两个组件必须采用分布式部署。<br>对于Nova，因为Nova-Compute是控制和管理虚拟机的，所以它必须部署在计算节点上，而Nova其它几个服务则应该部署在控制节点上。特别要强调的是，Nova-Compute和Nova-Conductor一定不能部署在同一个节点上，因为二者分开的目的就是为了解耦。<br>对于Neutron，Neutron的插件或Agent需要部署在网络节点和计算节点上，而其它部分，如Neutron Server可以部署在控制节点上。<br>②计算节点：指实际运行虚拟机的节点，就是OpenStack的管理的那些虚拟机实际上最后是在计算节点上运行的。<br>③存储节点：可以是提供对象存储的Swift的节点，或者是Swift集群的Proxy节点，也可以是一个其它服务的存储后端。<br>④网络节点：主要是实现网关和路由的功能。</li>
</ul>
<ul>
<li>OpenStack的复杂部署架构：要点如下：<br>①规模较大的情况下，把各种管理服务部署到不同的服务器上。<br>②把OpenStack的同一个服务部署到不同的节点上，形成双机热备或者多机热备的高可用集群。（或者可用负载均衡集群的方式去实现高可用）<br>③在复杂的数据中心环境中，考虑如何与第三方服务进行对接和集成。（如LDAP服务，DNS服务等）</li>
</ul>
</blockquote>
<h2 id="第三章-OpenStack各组件解析（基础）"><a href="#第三章-OpenStack各组件解析（基础）" class="headerlink" title="第三章 OpenStack各组件解析（基础）"></a>第三章 OpenStack各组件解析（基础）</h2><p>1.Nova组件解析</p>
<ul>
<li>Nova的架构<br>除了先前介绍的七大组件外，在此补充两个组件：nova-conslole，nova-consoleauth，它们的作用是通过支持VNC 或SPICE（独立计算环境简单协议）客户端来访问虚拟机界面。<br>SPICE协议支持USB设备和多屏显示等功能，使用它需修改nova.conf文件。</li>
<li>Nova对虚拟机的调度机制<br>①placement (放置): 把虚拟机放在哪个物理机上启动<br>②migration(迁移):从哪个物理机迁移到哪个物理机<br><em>实际上Nova中的调度器(Scheduler)只完成了placement (放置)的工作，migration(迁移)实际上是由其它组件协同完成的。<br>*</em>配置Nova.conf文件：Nova-Scheduler基于Filters对虚拟机进行调度的机制分为两步，第一步是通过Filters筛选宿主机(含有Compute)这，第二步是对虚拟机进行排序，Nova中该排序叫称重（weighting），最终完成调度算法，决定了应用哪台宿主机上启动哪台虚拟机。</li>
</ul>
<blockquote>
<p>注：在nova.conf中可以通过ram_allocation_ratio参数设置内存的超配比例，其前提是使用RamFilter。</p>
</blockquote>
<p>2.Swift组件解析</p>
<ul>
<li>Swift历史相对较长，比较独立，它和其它组件的耦合度比较低，有自己完整的存储体系，不依赖第三方软件或设备（如不依赖keystone做用户认证和建权）。<br>★对象存储：采用RESTful接口，支持直接从互联网访问存储系统进行数据的读写。</li>
<li>Swift接口：它和其它组件接口类似，也是RESTful 的Web API，总共有四个部分组成：第一个是HTTP操作（GET,POST,PUT或DELETE）；第二个是认证信息（主要是用户的身份信息）；第三个是指示资源地址的URL（包含域名或地址及Account, Container,Object）；第四个是（可选项）数据和元数据。</li>
<li>Swift其它要点：<br>Swift的架构：整体架构是RESTful  API，它是通过一个叫Proxy Server来实现的。（可对它进行扩展，做Load Balancer，用它去接收上面的HTTP请求，然后把请求转发到实际的Storage Server上）<br>搭建Swift时的注意事项：<br>a.（小规模集群）采用全对等架构，即它的每个(Server)节点都一样。<br>b.用Load Balancer把服务器组成一个集群。<br>c. （小规模集群）每个服务器是一个zone。<br>d. 小规模Swift集群，服务器数量最少是5个。（或说最小集群是五个服务器）<br>e. 不要用虚拟机和RAID。（不要把Swift放到虚拟机里去做实现。）<blockquote>
<p>附：Swif 2.0的新功能：<br>a.存储策略（核心功能）：让用户能够选择数据的存储策略。</p>
</blockquote>
</li>
</ul>
<p>3.Cinder组件解析</p>
<ul>
<li>传统数据中心的存储设备：SAN或盘阵，指一类设备，通过网络连接给服务器提供存储空间。SAN设备和服务器之间的网络连接主要有两种形式，第一种叫Fibre Channel（FC），用专用光线连接网络; 另外一种叫iSCSI，基于以太网协议/IP协议。</li>
</ul>
<blockquote>
<p>注：Cinder存储服务可以为虚拟机提供云硬盘。</p>
<ul>
<li>Cinder API<br>①不同于Swift的RESTful API，它提供一些操作和管理功能<br>②实际流量是不通过Cinder的这些组件的，而是直接通过存储设备和服务器之间的网络连接走的，该连接可以是FC（光纤通道）或iSCIS（基于IP的数据传输通道）传输数据到服务器。</li>
<li>Cinder Volume<br>①通过Driver适配其它设备。（屏蔽底层硬件异构性）</li>
</ul>
</blockquote>
<p>4.Neutron组件解析</p>
<ul>
<li>传统数据中心的网络：它分为几个层(Tier)，首先是服务器接入的第一级交换机叫接入交换机（往往在机架的顶部又称为(TOR)架顶交换机）；往上会接入一个汇聚层的交换机叫汇聚交换机（往往放在一排机架的顶头位置）；再往上会接入核心交换机，它把汇聚交换机连接起来，往往不只一个。</li>
<li>根据ISO网络模型，网络分为七个层(此处是协议栈里的层，layer)，OpenStack和Neutron主要关注其中的二三层，分别是数据链层和网络层。</li>
<li>在OpenStack和Neutron出现之前的虚拟化网络：用Qauntum去虚拟化网络，它使用linux系统里的一个软件叫虚拟网桥，它实现的网桥不存在物理信号问题，可简单为它是一个二层的交换机（跑在服务器虚拟机内部，把虚拟机都连接到此交换机上），可用它来搭建一个虚拟化环境，但是如果放到云环境中去，涉及租户间流量隔离问题，此网桥就不满足需求了，因为它是连通的（把所有虚拟机连接在同一个虚拟网络里），跟普通交换机无太大区别。</li>
<li>Nova中的一个管理网络模块Nova Network在前面网桥的基础上增加了一个模块，它可以有两种工作模式：①Flat DHCP工作模式②基于VLAN的隔离 ，它勉强满足了云的要求，所以可在一个简单的，对网络要求不高的云计算环境中使用Nova Network实现一个比较简单的网络。</li>
<li>Neutron功能<br>①VLAN隔离<br>②软件定义网络（SDN）<br>如L2-in-L3隧道，GRE 隧道等，还支持OpenFlow（SDN协议）<br>③第三方API扩展<br>④第三方Plugin扩展</li>
</ul>
<blockquote>
<p>注：可见通过Neutron，租户可以定制rich topology的虚拟网络；可以通过各种agent和plugin实现具体功能并和第三方设备，软件对接。<br>eg.构建一个基于三层架构的Web服务：<br>Web页面服务器；应用服务器；数据库服务器</p>
</blockquote>
<p>5.Horizon组件解析</p>
<ul>
<li>提供可视化GUI。OpenStack原生的Horizon满足不了需求，需在其上做二次开发。</li>
<li>Horizon内部架构<br>可参照python的一个Web应用框架django。Horizon的内部设计分为三个层次：<br>① Dashboard ②  PanelGroup ③  panel<br>Horizon三级代码组织形式：<br>① horizon: 表格，标签页，表单，工作流 ，base.py文件(实现动态加载panel)<br>②openstack_dashboard:  dashboard子文件（包含各个面板的实现代码，即业务逻辑都在里面，它会去加载或调用horizon文件夹里的那些组件）</li>
</ul>
<p>6.Glance组件解析</p>
<ul>
<li>Glance架构：上层Glance  API Server(提供RESTful API) ,所有访问请求会通过它；<br>Registry Server(提供镜像注册和检索服务)；Store Adapter【和Cinder类似，可使用不同存储后端，如Filesystem Store(可理解为Glance本地的一个文件存储), 还有Swfit Store,S3 Store, HTTP Store ，这些都是通过HTTP协议来访问的。所以Glance可以看成是一个典型的对象存储应用。】</li>
<li>和Swift一样，可以把Glance的API Server做横向扩展，然后给它做一个负载均衡的集群，下面再转到实际的存储后端去。但不同的情况是，Glance存储和管理的镜像，有的镜像用户访问量特别巨大，所以虽然对Glance的API Server做了负载均衡，实际的后端访问负载还是会落到一个点上，给它造成很大压力。为解决这个问题Glance提供 了一种缓存机制，使每个通过Glance到达服务器的Server端的镜像都会缓存到API Server上，如果我们有多个API Server，随着用户访问请求的增多，被经常访问的同一个镜像会在每一个API Server上都有一份，后续再有访问请求的时候，它就会直接调用API Server上的这个镜像文件，而不会再去访问到存储后端上来。而且这个机制对终端用户来说是透明的，即终端用户并不清楚Glance服务获取的这个镜像到底存在哪里。（注：如果我们只有一个节点提供API服务，这种缓存机制就没有意义了。）</li>
<li>缓存管理注意事项：<br>a.控制cache总量的大小（它有cache总量大小的控制）：周期性的运行一个命令来处理cache总量的大小限制。<br>b.清理状态异常的cache文件。<br>c.预热某些热门镜像到新增的API节点中：通过命令预先把一些比较热门的镜像先加载到新增的API节点中。<br>d.手动删除缓存镜像来释放空间</li>
</ul>
<ol>
<li>KeyStone组件解析</li>
</ol>
<ul>
<li>KeyStone的作用：<br>a.权限管理：用户，租户，角色（Role,keystone访问控制机制的核心）。</li>
</ul>
<blockquote>
<p>★注：用户和租户之间是多对多的关系。可通过Role进行权限管理以及将同一个用户分配到不同的tenant。<br>b.服务目录：服务，端点</p>
<ul>
<li>keystone只是云安全的一部分，二者不可等同。公有云上常见的安全防护手段：<br>a.安全访问：允许使用安全的Https访问<br>b.内置防火墙功能：通过配置内置防火墙让云上的环境或应用更安全<br>c.加密数据存储<br>d.帮助租户监测安全状况：主动监测租户的安全状况并给出提示</li>
</ul>
<p>问题集：</p>
<ul>
<li>比较Swift和Cinder两种存储之间的异同<br>异： Swift比较独立，它和其它组件的耦合度比较低，有自己完整的存储体系，不依赖第三方软件或设备（如不依赖keystone做用户认证和建权）,采用RESTful接口，支持直接从互联网访问存储系统进行数据的读写。<br>而Cinder本身并不是提供数据存储的，它需要接一个存储的后端，即EMC的散设备等，它有一个很重要的功能叫卷管理功能。虚拟机并不直接去使用存储设备（或使用后端的存储系统），它使用的是虚拟机上的块设备，可称为卷(Volume），实际上Cinder就是去创建和管理这些Volume，并且把它挂载到虚拟机上。<br>同： 二者整体架构都是RESTful  API，但Swift是通过一个叫Proxy Server来实现的。Cinder API不同于Swift的RESTful API，它提供一些操作和管理功能。</li>
<li>比较Neutron和Nova-Network的异同<br>Nova Network只是早先Nova中的一个管理网络模块，它在网桥的基础上增加了一个模块，它可以有两种工作模式：①Flat DHCP工作模式②基于VLAN的隔离，它勉强满足了云的要求，所以可在一个简单的，对网络要求不高的云计算环境中使用Nova Network实现一个比较简单的网络。Neutron做为一个Openstack项目出现之后，租户可以定制rich topology的虚拟网络；可以通过各种agent和plugin实现具体功能并和第三方设备，软件对接。</li>
</ul>
</blockquote>
<h2 id="第四章-OpenStack各组件解析（进阶）"><a href="#第四章-OpenStack各组件解析（进阶）" class="headerlink" title="第四章 OpenStack各组件解析（进阶）"></a>第四章 OpenStack各组件解析（进阶）</h2><p>1.Ceilometer组件解析</p>
<ul>
<li>Ceilometer又称为Openstack Telemetry: 远程测量收集数据</li>
<li>Ceilometer主要目的：为计费提供数据支持</li>
<li>计费用和监控用计量数据的区别：<br>a.侧重点    b.不可抵赖性</li>
<li>Ceilometer要点：<br>a.原始数据的来源：<br>①通过AMQP消息中间件收集各个组件发出的消息<br>②通过Ceilometer的agent（可扩展）调用Openstack各个组件的API获得数据</li>
</ul>
<blockquote>
<p>注：支持第三方的agent，plugin或driver来扩展Openstack是常用的手段。</p>
</blockquote>
<p>③在每个计算节点上运行Ceilometer的polling agent获得虚拟机的信息。<br>b.数据的存储：<br>①和Nova及Cinder等使用MYSQL作为默认的后端存储不一样，Ceilometer默认的后端数据库是MongoDB(是一个key-value数据库)，当然它也可以用Hbase，MYSQL等数据库。<br>c.（如何提供给）第三方系统<br>①通过Ceilometer 的API获得计量数据，设置报警条件和预值。</p>
<p>2.Heat组件解析<br>Heat又称为Ochestration：把一个IT系统的各个模块和资源组织，调度起来。它和AWS里的CloudFormation比较类似，它按照用户写的模板或脚本(Template)把Openstack的各种资源（如虚拟机或卷）实例化并组织起来形成一个完整的应用。按照Tempalte生成的东西叫stack(栈)。Tempalte写了创建一个stack需要用到哪些资源，及这些资源的相互关系。Heat的主要任务就是负责stack的创建，更新和销毁。(创建命令：heat stack-create  …  -template-file …)</p>
<blockquote>
<p>附：完整的Template包括， version ,description , resources，parameters, outputs<br>*更复杂的结构：创建一个wordpress网站；创建一个三层架构的网站；可以拆分为几个Template分别实现不同功能。</p>
<p>注：Heat可以和Ceilometer配合使用来实现auto scaling，另外Heat可兼容CloudFormation模板。</p>
</blockquote>
<p>3.Trove组件解析</p>
<ul>
<li>Trove的功能：根据用户的请求创建一个包含数据库的虚拟机</li>
<li>数据库的建立：可以是创建完虚拟机后由trove去安装；也可事先做好trove的镜像（里面已经安装好数据库了）。后者效率更高，Trove支持关系型数据库MySQL, NoSQL数据库，MongoDB, Cassandra等</li>
<li>Trove的功能实现依赖四个组件：<br>a.Trove API：提供RESTful API<br>b.Taskmanager: 完成管理命令的执行（创建/销毁/管理示例，操作数据库），它的主要工作方式主要是去监听RabbitMQ这个中间件上的MQP等调用请求并实现。<br>c.Trove-Conductor: 和Nova-Conductor比较类似，负责和数据库交互。<br>d.Guest agent: 类似于Neutronagent ，对应数据库</li>
<li>Trove目前面临的挑战：不支持自动配置数据库的HA</li>
</ul>
<p>4.Sahara组件解析（Sahara原名叫Savanna）</p>
<ul>
<li>Sahara作用：<br>a.在Openstack上快速创建Hadoop集群<br>b.利用Iaas上空闲的计算能力做大数据的离线处理</li>
<li>Sahara的架构（原理）要点：<br>a.Horison：里包含Sahara的dashboard<br>b.Plugin：用来支持Hadoop各种发行版<br>c.Swift: 存储持久化数据（不该再放到Hadoop的HDFS里，因为它的生命周期和虚拟化的Hadoop集群的生命周期一样）<br>d.Sahara API：不同于其它组件,它的API分为两个服务入口，一个叫Service.api，另外一个叫Service.edp.api。</li>
<li>Sahara的使用模式<br>①Iaas模式/管理模式：<br>a.节点（此处不同于先前讲的计算节点等），它是运行Hadoop集群的机器。<br>b.节点组：按照节点类型划分，通过节点组模板定义节点组<br>c.集群：完整的Hadoop集群，通过集群模板定义集群<br>d.Job：（有工作流的性质），它可能是若干个Hadoop job组织起来形成Sahara<br>②Pass,DAaas模式/用户模式/EDP模式<br>a.前提：至少创建一个Hadoop集群<br>b.准备工作：上传要处理的数据；编写job并上传；给Sahara一个三元组（即调用EDP API时的参数，分别是使用哪个集群，数据元和素在哪，要运行的job是什么）</li>
</ul>
<p>5.Ironic组件解析</p>
<ul>
<li>用Ironic（由单词iron演化而来）实现实现对物理机械的管理或者说用物理机器实现云服务。</li>
<li>它和Openstack在部署架构上管理虚拟机和物理机器的区别：<br>a.在控制节点上多了一个Ironic API组件<br>b.在Compute  Node上除了Nova-Compute, Neutron  agent以外，还有一个Ironic Conductor 。（注：此处的节点和先前的节点不一样，它和Cinder Volume类似，并不是实际提供存储资源的节点）</li>
<li>它和Openstack在计算资源调度流程上或启动一台机器的工作流程上的区别：<br>物理机器节点上的Nova Compute调用Ironic API，实际启动的物理机器节点或说实际提供计算资源的物理机器节点是由Ironic Conductor通过PXE ,IPMI远程管理的。</li>
<li>Ironic实际上是由Nova的一个部分演化而来（以前Nova中专门管理物理机器的Nova driver）（同样的，先前说的Cinder是Nova Volume演化而来）</li>
</ul>
<blockquote>
<p>问题集：<br>Heat中的模板和Sahara中的模板的异同：<br>异:  Heat和AWS里的CloudFormation比较类似，它按照用户写的模板或脚本(Template)把Openstack的各种资源（如虚拟机或卷）实例化并组织起来形成一个完整的应用。按照Tempalte生成的东西叫stack(栈), Tempalte写了创建一个stack需要用到哪些资源，及这些资源的相互关系。<br>Sahara 的Iaas模式/管理模式中，通过节点组模板定义节点组，通过集群模板定义集群。<br>同:  都包含了配置信息，用来对组件进行配置，通常包括 version ,description , resources，parameters, outputs等信息。</p>
</blockquote>
<h2 id="第五章-OpenStack实际操作"><a href="#第五章-OpenStack实际操作" class="headerlink" title="第五章 OpenStack实际操作"></a>第五章 OpenStack实际操作</h2><p>1.OpenStack部署环境准备</p>
<ul>
<li>创建一个路由器（Router）;创建一个交换机（用Neutron 中的Network，它相当于交换机，需配置子网（广播域）），最后把两者连接起来。为了让网络里的连接其它设备能够正常访问公网（Internet）需用Floating IP（也是Netron中的一个概念，它实际上就是云计算环境可用的公网IP）,它有两种用法，一是将其绑定到路由器上，二是将其绑定到云主机上（让这台云主机和外网相连通。它显示有2个IP,但实际只有一个IP，它是通过Neutron的一种机制把两个IP映射起来。当然我们也可通过Neutron实现修改虚拟机真正的IP地址和MAC地址）。</li>
<li>创建云主机（Instance）</li>
</ul>
<p>2.KeyStone的安装部署</p>
<ul>
<li>a.登录Controller节点安装KeyStone(apt-get)，并修改KeyStone配置文件【修改etc目录下keystone.conf文件中的三个部分：和数据库连接相关的设置；修改或设置写log的位置（log_dir=/var/log/keystone）；设置keystone服务和其它服务共享的一个token】</li>
<li>b.创建用户（需要带两个参量：token和url），创建租户，创建角色；创建服务</li>
<li>c.Controller节点上）把常用参数（username,password,tenant-name,auth-url等）作为环境变量导出</li>
</ul>
<p>3.Glance的安装部署</p>
<ul>
<li>a.安装Glance（安装Glance服务及Glance的python客户端），并修改Glance配置文件【主要修改etc目录下glance-api.conf文件和glance-registry.conf。首先进行glance-api.conf和glance-registry.conf文件中和数据库连接相关的配置，且检查/var/lib/glance目录，如果存在sqlite数据库文件（glance.sqlite）需将其删除，防止误读；而后修改glance-registry.conf】</li>
<li>b.创建Glance数据库(MySQL)并同步（glance-manage db_sync）</li>
<li>c.用keystone命令给Glance创建用户并添加该用户到先前的租户里</li>
<li>d. 修改glance-api.conf文件和glance-registry.conf文件中keystone相关的设置，<br>并在keystone中注册Glance以及它的端点。</li>
<li>e.上传镜像</li>
</ul>
<p>4.Nova的安装部署</p>
<ul>
<li>在Controller节点进行安装，此处不能和先前一样写个Nova，要写清楚具体安装哪些组件（如Scheduller,Conductor,Nova-api,Nova的python客户端等）。</li>
<li>在Compute节点安装Nova-compute-kvm(此处kvm实际上是由qemu模拟的一个虚拟机)，没有Neutron则需安装nova-network，nova-api-matadata .</li>
<li>同先前组件一样，先修改nova.conf相关配置，同样要去检查/var/lib/glance目录，如果存在sqlite数据库文件将其删除，创建数据库(MySQL)并同步（把数据项或信息填充到现在的数据库，glance-manage db sync，不同于先前的命令，此处无下划线）</li>
<li>继续修改nova.conf中keystone相关的设置，在keystone里创建用户并注册服务和端点。</li>
<li>在Compute节点上配置nova.network.api.API</li>
<li>在控制节点上创建网络</li>
<li>启动虚拟机（用nova boot命令）</li>
</ul>
<p>5.OpenStack支撑服务的安装配置<br>支撑服务：NTP（时间同步服务），mysql数据库服务，RabbitMQ（消息中间件服务）。配置host文件，实现通过主机名访问虚拟机。</p>
<ul>
<li>NTP服务：它有两个作用，一是将本机时间和网络上的一台时间同步器去同步；另外一个作用是将本机作为一个时间同步器提供给其它节点去使用。<br>在Opentstack部署环境中，建议让Controller结点去和互联网上的一个时间同步器同步，让其它结点和这个Controller结点同步，这样一来，其它结点和这个Controller结点的时间同步就在一个局域网内，时间同步性更高。安装完NTP后为实现把Controller结点做为时间同步源，需在其它结点上编辑它的配置文件（etc文件夹下的ntp.conf,加上server controller）。</li>
<li>在Contorller结点上安装mysql服务（需安装python-mysqdb客户端和mysql-server服务进程），并修改配置文件（etc文件夹中mysql下的my.cnf,<br>修改bind-address（绑定访问mysql服务器所需要的IP地址）；修改或添加数据库引擎配置（mysql默认或推荐的数据库引擎是InnoDB）。<br>注：【实际运用中可把数据库服务安装到单独的一个机器上(可配置全ssd)，公司里常用全ssd服务器来支撑数据库服务，提高其性能】<br>其它结点上不用再安装数据库服务，只需安装一个python客户端即可，Openstack就可以访问Contorller结点上的那个数据库了。</li>
</ul>
<blockquote>
<p>附：安装mysql时会创建一个匿名用户和一些Database，为正常使用起见可将其清除（可手动清除，也可用mysql提供的一个命令：mysql_secure_installtion）。</p>
<ul>
<li>在Contorller结点上安装RabbitMQ服务。消息中间件还可用别的如Qpid，ZeroMQ</li>
</ul>
</blockquote>
<p>6.通过图形界面使用OpenStack</p>
<ul>
<li>除了安装horizion(dashboard)，还需安装apache等其它几个服务，这些都是为了显示动态网页所需要的。另外还要删除一个包（openstack-dashboard-ubantu-theme），因为它影响到horizon图形界面的显示。然后修改配置文件（etc中openstack-dashboard下的一个.py结尾的文件local_settings.py），修改BACKEND和LOCATION（它们是对显示的web界面缓存的设置），让其参数与memcached中一致。</li>
</ul>
<p>7.通过命令行使用OpenStack</p>
<ul>
<li>先前多数是在Controller节点上用过命令行访问本地的服务，此处介绍远程访问的方法。为了模拟远程访问的环境，可在使用的公有云里创建一个ubuntu的云主机作为客户端（还是接入先前的子网），并修改配置文件（hosts）。然后安装相应客户端（如python-novaclient）。</li>
</ul>
<blockquote>
<p>注：可以创建脚本，把导出环境变量的命令都放在里面，方便以后使用（里面的命令需根据自己的环境进行修改）。之后不直接执行脚本，而是用source命令执行脚本，这样才能把脚本里设置的环境变量带到当前用户的操作环境中。（可用echo命令查看环境变量设置是否成功）</p>
</blockquote>
<h2 id="第六章-OpenStack扩展话题"><a href="#第六章-OpenStack扩展话题" class="headerlink" title="第六章 OpenStack扩展话题"></a>第六章 OpenStack扩展话题</h2><p>1.OpenStack自动化部署</p>
<ul>
<li>分为三个层次：<br>A.单节点自动安装：常用于准备一个开发环境，常用工具是DevStack<br>B.集群化安装：最常用工具是puppet<br>C.多个集群安装部署：典型代表工具是Mirantis公司推出的fuel</li>
<li>DevStack的安装演示（单节点自动安装的实际操作过程）<br>a.创建云主机。更新一下安装源（apt-get update），安装git，通过git clone命令下载DevStack的源代码。然后用devstack文件夹里提供的一个工具创建一个用来安装和运行DevStack的用户（./create-stack-user.sh）。将下载的源码在当前用户的home文件夹下拷贝一份（可从本地拷贝或再次从源端下载），找到devstack文件夹中samples下的local.conf文件,拷贝一份到上一级目录并修改其中的相关配置（把HOST_IP修改成当前当前机器的内网IP）。<br>b.运行./stack.sh脚本，进入自动安装过程。</li>
</ul>
<p>2.Hadoop云化时存在的问题</p>
<ul>
<li>Hadoop是用来做大数据处理的一个工具，它也有自己庞大的生态圈，其中最重要的两个软件是HDFS（分布式存储系统），MapReduce（任务调度框架）</li>
</ul>
<blockquote>
<p>注：HDFS把文件分成块，把块做三个副本存储到不同节点上，形成一个比较高可靠性的文件系统；MapReduce把我们提交的数据处理任务（job）拆分成不同的task分发到不同的节点上，以实现并行处理。MapReduce最大的特点是能够把任务调度到离数据近的节点上，尽量减少数据在网络间的传输，使我们可用通用廉价的X86服务器和网络设备来构筑一个数据并行处理系统。</p>
<p>★Openstack虚拟机调度和Hadoop任务调度实际上是两个不同层次的资源调度。要把Hadoop做云化就需要解决两个不同层次上的资源和任务调度问题。Hadoop最重要的两个部分HDFS和MapReduce云化时也会出现相应问题，为解决相关问题Hadoop提供了一个由VMware主导的开源项目HVE(Hadoop Virtual Extensions)。</p>
</blockquote>
<p>3.基于OpenStack实现Hadoop云化</p>
<ul>
<li>Sahara分别从部署管理和提供数据处理服务两个层次上对Hadoop云化做了一些工作。</li>
<li>HDFS和Swift集成：在Hadoop集群里仍用本地根硬盘来构筑 HDFS，但是把数据源和job放在Swift里。此外，由VMware主导的开源项目BDE(Big Data Extensions)，它和Openstack的Sahara很类似，但是在各个方面都做得比Sahara好得多，且它和HVE 集成做得很好。</li>
</ul>
<p>4.Ceph简介</p>
<ul>
<li>Ceph现在经常被用来做为RBD设备提供块存储服务。</li>
<li>Ceph层次结构：<br>底层RADOS，中间层LIBRADOS ,顶层RADOS GW, RBD, CEPH FS</li>
</ul>
<p>① RADOS：可靠的，自动化的，分布式的对象存储。底层是一个完整的存储系统，它的核心是OSD(Object Storage Daemon)，Daemon是一个服务软件（进程），它和Cinder里定义的OSD(Object Storage Device)之间有很强的对应关系，可认为是其简略版本。</p>
<blockquote>
<p>注：不同于Swift存储 的对象（文件），Ceph的对象实际上是把一个文件拆分成若干个Object，分别放到底层的存储设备上。</p>
</blockquote>
<p>★RADOS逻辑结构：OSDs , Monitors , Clients</p>
<blockquote>
<p>注：此处的客户端和Swift客户端有本质区别，Swift客户端只是用Pyhon写的一个供用户使用能够调用RESTful 接口的客户端程序而已，没有它我们直接调用RESTful 接口也可以读写Swift，但是在RADOS里如果没有Clients,整个数据读写就难以实现，它是存储系统的一部分。</p>
<p>★Ceph系统中的寻址流程（文件存储到底层OSD上）<br>它首先把文件拆分成若干个Objects，然后把Objects放到PG组里面，每个组再通过CRUSH算法给它映射到不同的OSD上。此存储过程特点是它每一步都是通过计算得到的，它中间没有查表，这使得Ceph拥有较好的扩展性。</p>
</blockquote>
<p>②LIBRADOS: 提供一组直接访问RADOS的API<br>③RADOS GW, RBD, CEPH FS：RADOS GateWay把底层对象存储系统往外再次封装，提供兼容Swift和亚马逊S3对象存储接口，这个接口也是HTTP的。RBD经常作为Cinder的后端为虚拟机提供卷。CEPH FS是在Ceph基础上封装了一个POSIX接口，形成文件系统。</p>
<p>5.Ceph在OpenStack中的应用</p>
<ul>
<li>Ceph在OpenStack中受欢迎的原因：<br>①有了Ceph，可基于X86搭建分布式块存储系统</li>
</ul>
<blockquote>
<p>附：块存储有强一致性和高性能的要求，这对于Swift和HDFS都是没有或比较弱的。<br>★Cinder支持Ceph提供的RBD设备，二者结合可基于X86普通服务器更加廉价方便地搭建一个块存储系统提供（卷）给虚拟机去使用。<br>②提供Swift兼容的对象接口<br>③★Ceph和Swift仍不可互为替代，二者比较如下：<br><img src="./images/Ceph%20VS%20Swift.jpg" alt="enter description here" title="Ceph VS Swift.jpg"><br>案例一：目前OpenStack规模小，节点数量少，此时使用Swift节点浪费存储，可选用Ceph<br>案例二：提供云盘服务（面对大量用户，强调用户体验，用户可选存储策略（Storage Policy）），此时选用Swift更好，它更好地支持规模化部署，有先进的Feature，成本比Ceph更低<br>④现在OpenStack所有存储都（开始）支持Ceph作为后端</p>
</blockquote>
<p>6.OpenStack与Docker</p>
<blockquote>
<p>附：HyperVisor：在一个宿主机上搭建环境，可在环境里创建虚拟机，再在虚拟机里装客户操作系统(Guest OS)，然后在其上面装中间件，之后再装应用等。<br>Container技术：另外一种虚拟化技术，无需再装Guest OS，而直接基于宿主机操作系统来操作，可在其上做运行环境隔离，资源划分等，并形成容器，让应用在容器中运行。容器之间底层是共享一个操作系统的，甚至可以共享一些公用的库。和传统的HyperVisor相比，它的优势在于省去了Guest OS的开销；劣势在于只能使用和宿主机相同的操作系统。</p>
</blockquote>
<ul>
<li>Docker：是基于容器的一个引擎，让开发者可以打包应用，并将其依赖包打到可移植的容器里，而容器可发布到任何linux机器上。OpenStack里将Docker也看成是一种HyperVisor</li>
<li>OpenStack+Docker:（结合点）<br>①使用Swift做Docker镜像的存储后端<br>②Nova里有针对Docker的Driver或插件，可用Nova调度和管理Docker容器。<br>③使用Heat来实现Docker的Ochestration<br>④基于Neutron设计与实现适用于Docker的SDN方案<br>⑤使用Glance来管理Ducker镜像<br>……</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/25/Android/" itemprop="url">
                  Android
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-25T00:00:00+08:00" content="2016-04-25">
              2016-04-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程基础/" itemprop="url" rel="index">
                    <span itemprop="name">编程基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一．adb的安装及使用"><a href="#一．adb的安装及使用" class="headerlink" title="一．adb的安装及使用"></a>一．adb的安装及使用</h3><p>配置adb(后台使用adb):在系统环境中的path添加adb路径：sdk中的platform-tools</p>
<h3 id="二．-安卓系统架构"><a href="#二．-安卓系统架构" class="headerlink" title="二． 安卓系统架构"></a>二． 安卓系统架构</h3><h3 id="三．-安卓生命周期"><a href="#三．-安卓生命周期" class="headerlink" title="三． 安卓生命周期"></a>三． 安卓生命周期</h3><ul>
<li>四个状态：<br>（1）运行<br>（2）暂停<br>（3）停止<br>（4）死亡</li>
<li>七个函数：</li>
</ul>
<h3 id="四．-开发基础"><a href="#四．-开发基础" class="headerlink" title="四． 开发基础"></a>四． 开发基础</h3><p>1.安卓最基本的文件结构</p>
<ul>
<li>Manifests: 反射层文件，启动时加载</li>
<li>java代码： 安卓自动调用生命周期方法把.xml文件结合起来</li>
<li>res（资源文件）：</li>
</ul>
<blockquote>
<p>注：Java代码实现功能设计，.xml实现渲染（实现颜色，布局，大小等），如此安卓实现二者的分离。</p>
</blockquote>
<p>2.安卓本质是一个优秀的框架，适合做界面开发，功能由Java代码实现（GUI开发是Java的弱项，因为它没有把结构和表现做分离</p>
<p>3.安卓长度单位</p>
<p><code>（为适应不同设备）使用与像素和密度无关的单位：dp（可自动换算：1dp=[density/160]px），sp（用于设定与density及scale无关的字体单位）</code></p>
<p>4.代码调试<br>用日志器【不能用system.out.println()，它只能是在真机上执行完毕后由adb回显数据。】<br><code>eg.Log.i(“标签” , ”要输出的内容”);</code></p>
<p>5.安卓编译原理</p>
<p><code>IDE把源代码进行编译（生成.des字节码文件，与sun公司的.class文件不尽相同），编译完后进行打包（. apk文件），之后通过安卓的adb传到AVD或真机上，传完后adb再发送一条指令把安装好的.apk进行启动，启动过程中adb会收集到很多调试信息并返回。</code></p>
<p>6.其它</p>
<p><code>在Manifests文件中可设置用户权限：&lt;uses permission ...&gt;</code></p>
<h3 id="五．安卓布局管理"><a href="#五．安卓布局管理" class="headerlink" title="五．安卓布局管理"></a>五．安卓布局管理</h3><blockquote>
<p>gravity: 容器自身对于内部组件的重力位置。<br>layout_gravity: 组件自身对于容器的重力位置。</p>
<blockquote>
<ul>
<li>gravity和layout_gravity可能由冲突，如gravity重力场在下，而layout_gravity在上。</li>
<li>gravity对于垂直方向的影响优先于layout_gravity，对于水平方向的影响低layout_gravity。</li>
</ul>
</blockquote>
</blockquote>
<ol>
<li><p>线性布局（LinearLayout）<br>1）不同于Java的流式布局（flow）, 线性布局不会自动向下横排，计算时要考虑其大小。<br>2）默认横向排列，可设置为竖向排列。【orientation=”vertical”】<br>3）默认重力场在左上角，可以修改。【gravity=”bottom”(左下)，=”bottom|right”(右下) …】<br>4）重力场可在容器上设置，也可在组件上设置。<br>5）组件分配比例问题：layout_weight=”数字” //数字表示权重（空间占比），且”layout_weight”优先级高于”wrap_content”和dp。（横排方向的组件大小设置以dp为准）<br>6）LinearLayout容器对外而言其自身也是组件，可嵌套使用。</p>
</li>
<li><p>相对布局（RelativeLayout）<br>1）按照各子元素之间的位置关系完成布局（根据前一个已定位的组件来确定自身的位置）。是安卓五大布局里最灵活的一种布局结构，比较适合一些复杂界面的布局。<br>2）给一个组件定位，即加id（@+id/a）。另一个组件即可根据该id实现自身定位。<br>【如layout_toRightOf=@id/a(在a右边)，_below(在a下面)，alignleft(与a左对齐) …】<br>3）可设置组件间的间距。（margin和padding）</p>
</li>
</ol>
<blockquote>
<p>★编程方式使用组件<br>基于配置文件使用静态布局管理器不能做一些动态上的组件控制。可将.xml配置文件所有内容移植到编码中实现灵活布局。</p>
</blockquote>
<ol>
<li><p>表格布局（TableLayout）<br>1）定义组件较多需按行（列）排列时可用表格布局。<br>2）它里面设置button无需设置高度和宽度，由其容纳的表格确定。<br>3）和html不同，它无td设置，只可设置行。（TableRow）<br>4）不设置其单元格大小则默认为装下其内容大小。可在容器设置单元格（列）的大小。<br>【如（stretchColumns=”0”(第1列扩展),=“1”，（第2列扩展）,=“0,1”（1，2列平分）】<br>5）可设置单元格（列）里的内容不可见。【如collapseColumns=”0”(第一列内容不可见)】<br>6）其它设置【如shrinkColumns（压缩）】</p>
</li>
<li><p>绝对布局（AbsoluteLayout）<br>1）以左上角的点为原点，用x,y来控制。（layout_x=”50dp”,layout_y=”100”）</p>
</li>
<li><p>其它布局（如网格布局(GridLayout)）</p>
</li>
</ol>
<h3 id="六．安卓Wegit组件（可视化控件）"><a href="#六．安卓Wegit组件（可视化控件）" class="headerlink" title="六．安卓Wegit组件（可视化控件）"></a>六．安卓Wegit组件（可视化控件）</h3><p>1）TextView：textColor；textSize,background …<br>2）EditText：hint(提示)；inputType(限定输入内容) …<br>3）ImageView: src(源):@drawalbe/图片名称 …<br>4）RadioButton（单选按钮）: checked=ture(默认选中)；允许加文本 …</p>
<blockquote>
<p>★两个单选按钮实现互锁:用RadioGroup包含两个RadioButton，并且都需要有id 。<br>RadioGroup自身也是ViewGroup,支持布局。它默认竖排，可设置为横排。（orientation=”horizontal”）</p>
<blockquote>
<p>注：要想知道是否选上，只需绑定id,然后调用isChecked()。</p>
</blockquote>
</blockquote>
<p>5）CheckBox（复选按钮）:默认竖排，同上，可将其放入LinearLayout，然后设置为横排。<br>6）Switch（控制开关）: 应用于开关控制（如wifi开关的控制）。安卓中还提供了另一个控件：ToggleButton .<br>7）SeekBar（拖动条）: max(设置最大值)；progress(设置当前值)</p>
<blockquote>
<p>★给SeekBar添加监听事件【（不用onClick）类比Java给一个按钮添加监听器】：<br>给SeekBar起名（添加id）<br>在onCreate中获取上述id(即实例化)并给它添加(set)相应的监听事件（含匿名内部类）。<br>【在此也可直接实现相应的监听事件接口（上述内部类便可用this代替）】<br>重写接口中的方法</p>
<p>★附：SeekBar控制图形透明度：改变Alpha（灰度）通道即可<br>给图片起名（添加id）<br>在onCreate中获取上述id(即实例化)并重写SeekBar监听接口中的方法（onProgressChanged()）。添加(set)Alpha(progress/100.0f)方法即可，注意Alpha（）参数要求为浮点型数据，100为SeekBar的max值，progress/100.0f将自动转换成浮点型数据。</p>
<blockquote>
<p><code>注：还可做调色板，改变其它三个颜色通道（RGB）即可：Color.rgb(x,y,z)//参数分别是红绿蓝颜色的分量，取值范围为0-255（int）。</code></p>
</blockquote>
</blockquote>
<p>8）RatingBar（星评图标）：是SeekBar的子类（二者完成同样动作，方式不一样而已）。<br>numStars（设定星数,默认星数为5个）；stepSize（选择方式，可设为选半颗星（=“0.5”））；<br>max(设置最大值)；progress(设置当前值)<br>9）ProgressBar（进度图标）: 默认样式为转圈，可更改其样式。style；max；progress …<br>应用：如显示播放或下载进度【开子线程，在里面实现更新即可）】</p>
<blockquote>
<p>★★补：三个重要控件【和后台数据有关；重点在于Adapter，和数据有关的都可以使用它】</p>
<blockquote>
<ul>
<li><code>注：Spinner和ListView的使用原理与AutoCompleteView一样，关键在于Adapter的使用。</code></li>
</ul>
</blockquote>
</blockquote>
<ul>
<li>1）AutoCompleteView（自动完成框）：表面看起来和文本框一样，关键在于它里面包含内容，打字时会有提示功能，可应用于用户检索功能。<br>completionThreshold【可设置自动完成的阈值（默认为2），=“1”(打一个字母就会出现提示)】<blockquote>
<ul>
<li>★AutoCompleteView需要增加一个Adapter（适配器）用于适配两个事件，View（或ViewGroup）和Data（从网络或数据库中获得）。<blockquote>
<ul>
<li>【Data要进入View，此过程称为渲染，即把一个数据渲染成一个View，此过程靠Adapter给我们自动完成。</li>
</ul>
</blockquote>
</li>
<li>AutoCompleteView使用方法：<br>给AutoCompleteView起名（添加id）<br>在onCreate中获取上述id(即实例化，假设为lv1)并给它增加(set)一个Adapter；</li>
</ul>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eg.此处要个Arrayadapter：</div><div class="line">Arrayadapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,View,data );</div><div class="line">setAdapter(adapter)【Adapter是泛型类，在此是个父类接口，要个adapter即可.】</div></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<ul>
<li><code>注：ArrayAdapter的构造有三个参数，它将自动在其内部实现渲染。
【第一个参数表示渲染位置，this表示当前位置；第二个参数为View；第三个参数为Data。】
【第二个参数写ViewId即可。可自己做一个View,但已经系统提供了一个View,可直接使用.（调用安卓jar包：android.R.layout.simple_list_item_1，它是TextView布局（源码）】</code><br><code>【第三个参数实际上是String数组，可外置。new String[]{“abc”,”def”,”g”,...}】</code><br><code>可给lv1添加事件:setOnItemClickListener(new onItemClickListener(){…});</code></li>
<li><code>注： 一个Item可能有多个View，此处不能实现给某个具体的View添加事件，因为渲染是在内部完成的，这也是ArrayAdapter的一个重大缺陷。</code><blockquote>
<ul>
<li><code>★获得数据有可有两种方式：可把View转换成TextView，然后getText()获得data值；也可以通过data加上position获得data的值，此处用后者更好些：Log.i(“tiger”,data[position]);
//点击某个区域可获得相应数据（此处只是作为整体组件进行响应）</code></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<ul>
<li><p>2）Spinner（类似html中的下拉列表）</p>
</li>
<li><p>3）ListView（列表显示）<br>ListView应用广泛。如果使用大量ListView可以做简化，即继承ListActivity。这个Activity专门为ListView服务，它有如下特点：<br>a.它自身内部就有一个ListView,所以无需布局文件。<br>b.它实现了onItemClickListener接口(即它自身就是监听器)这样一来便可减少不少工作。<br>我们无需setContentView(…)和setOnItemClickListener(…)，直接实例化一个数据和一个adapter，再添加一个监听器onListItemClick(…)即可。</p>
</li>
</ul>
<blockquote>
<blockquote>
<ul>
<li>★附：Adapter基本作用和原理：<br>1）Adapter将数据内容与组件进行绑定<br>2）AdapterView的所有继承类都是具备setAdapter(Adapter)<br>3）ListView,GridView,Spinner,ExapendableView是重要的子类型</li>
<li>*Adapter是一个父类型，我们使用时将会用到它的各种子类型，比较常见的三个子类型如：<br>①ArrayAdaper：支持泛型操作，最为简单，只能展示一行字。<br>②SimpleAdapter：有最好的扩充性，可以自定义出各种效果。<br>③BaseAdapter：是一个抽象类，继承它需要实现较多的方法，所以也就具有较高的灵活性。<br>④SimpleCursorAdapter:是SimpleAdapter的一个变种，它可以把一个Corsor对象映射到View上。可以认为是SimpleAdapter对数据库的简单结合，可以方便地把数据库的内容以列表的形式展示出来。（一般无需使用它）</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">eg1.SimpleAdapter</div><div class="line">★其最终目的是要把一个Map结构的数据映射到一个布局上，即把复杂数据变成一个布局文件(View)。</div><div class="line">使用示例：</div><div class="line">a.可先自定义一个layout布局（如sgt_layout），再写一个Activity类继承ListActivity。</div><div class="line">b.实例化一个数据: private List&lt;Map&lt;String,Object&gt;&gt; data;</div><div class="line">写一个方法进行初始化：          </div><div class="line">private void init()&#123;</div><div class="line">data = new ArrayList&lt;Map&lt;String,Object&gt;&gt;();</div><div class="line">Map&lt;String,Object&gt; mp1 = new HashMap&lt;String,Object&gt;();</div><div class="line">mp1.put(key,value);mp2.put(key,value);mp3.put(key,value);…//添加内容</div><div class="line">data.add(mp1); data.add(mp2); data.add(mp3); …//添加数据</div><div class="line">&#125;                        </div><div class="line">c.在onCreate()方法里调用init()产生数据，然后使用SimpleAdapter:</div><div class="line">SimpleAdapter adapter=new SimpleAdapter(this,data,View,String[]from,Int[]to);</div><div class="line">setListAdapter(adapter);</div><div class="line">＊注：SimpleAdapter的构造有五个参数，它将自动在其内部实现渲染。</div><div class="line">【第一个参数表示渲染位置，this表示当前位置。第二个参数是数据，第三个参数是先前自定义的布局。第四个参数是一个字符串数组（写key的数组，用它来找value）。第五个参数表示往哪渲染，它是一个Int[]类型数组（其id就是布局里定义的id），它要求data与View的position顺序对应。】</div><div class="line">d.可添加事件(仍不能实现给某个具体的View添加事件)，获得有关数据：</div><div class="line">onListItemClick(…)&#123;</div><div class="line">Log.i(“tiger”,data.get(position).get(“content”).toString); &#125;</div><div class="line">//点击content区域可获取相应数据。（此处只是作为整体组件进行响应）</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">eg2.BaseAdapter</div><div class="line">★需求----如果使用更加“复杂”的数据模型；如果需要更加精确的控制“适配“的细节；如果需要实现每个组件独立添加事件处理。</div><div class="line">*原理及细节：BaseAdapter是一个抽象类，需要继承并实现以下四个方法：</div><div class="line">int getCount()&#123; return as.length; &#125; //提交给渲染引擎（渲染的数据个数）</div><div class="line">Object getItem(int position)&#123; return as[position]; &#125;//返回自定义对象</div><div class="line">Long getItemId(int position)&#123; return position; &#125; //可自定义返回Object id</div><div class="line">View getView(int position,View convertView,ViewGroup parent)&#123;…&#125;//渲染引擎主要的操作代码，是渲染过程，返回View</div><div class="line">使用示例：</div><div class="line">a.可使用先前自定义的layout布局(如sgt_layout）,然后写一个Adapter类（sgtAdapter）继承BaseAdapter,复写它的四个方法。</div><div class="line">b.新建一个类（如Suguotai）设定属性和构造（自定义对象）,然后在Adapter类中用构造方法把自定义对象的数据传进来（例如可传进List&lt;自定义对象&gt;型数据（data） ）。</div><div class="line">c.int getCount()&#123;return data.seze();&#125;；</div><div class="line">Object getItem(int position)&#123; return data.get(position); &#125;</div><div class="line">Long getItemId(int position)&#123; return data.get(position).getId(); &#125;</div><div class="line"> </div><div class="line"> View getView(int position,View convertView,ViewGroup parent)&#123;</div><div class="line">   //用data和layout生成最终的View</div><div class="line">layoutInflater inflater=layoutInflater.from(context);//“吹”出View。</div><div class="line">context表示此ListView将来在哪个Activity中产生出来。而现在Apater类并不知道ListView将来究竟在哪个Activity中出现，所以在构造Adapter时应该把Activity传入。【Activity和Service都是Context的子类，此处声明一个Context属性传进来即可。】</div><div class="line">convertView=inflater.inflate(R.layout.sgt_layout,null);</div><div class="line">//第一个参数就是id，第二个参数ViewGroup可不管</div><div class="line">Suguotai s=data.get(position);//当前数据</div><div class="line">…//接下来将数据逐条渲染到View中：(id为layout里对应的id)</div><div class="line">eg. ImageView show=(ImageView)convertView.findViewById(R.id.sgtShow);</div><div class="line">show.getBackgroundResource(s.getShow());</div><div class="line">TextView title=(TextView)convertView.findViewById(R.id.title);</div><div class="line">title.setText(s.getTitle()); </div><div class="line">……</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//★可实现给某个具体的View添加事件，获得有关数据：</div><div class="line">eg. title.setOnclickListener(new onItemClickListener()&#123;</div><div class="line">…onClick(Viewview)&#123;</div><div class="line">Log.i(“tiger”,data.get(position).getTitle()); &#125;</div><div class="line">&#125;);</div><div class="line">return convertView;</div><div class="line">&#125;</div><div class="line">d.同SimpleAdapter的使用一样，先写一个Activity类继承ListActivity。</div><div class="line">e.实例化一个数据: private List&lt;Suguotai&gt; data;</div><div class="line">写一个方法进行初始化：          </div><div class="line">private void init()&#123;</div><div class="line">data = new ArrayList&lt;Suguotai&gt;();</div><div class="line">Suguotai s1=new Suguotai(id,…); Suguotai s2=new Suguotai(id,…);</div><div class="line">……//添加内容</div><div class="line">data.add(s1); data.add(s2); …//添加数据</div><div class="line">&#125;                        </div><div class="line">f.在onCreate()方法里调用init()产生数据，然后使用前面的sgtAdapter:</div><div class="line">sgtAdapter adapter=new sgtAdapter(this,data);</div><div class="line">setListAdapter(adapter);</div></pre></td></tr></table></figure>
<h3 id="七：安卓四大组件"><a href="#七：安卓四大组件" class="headerlink" title="七：安卓四大组件"></a>七：安卓四大组件</h3><blockquote>
<p>附: ★intent详解<br>1）是下述前三大组件之间及其内部的通信桥梁，负责消息传递。作用类比Servlet转发jsp页面中的request(中间对象)。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">eg1.（两个Activity之间的跳转）</div><div class="line">FirstActivity.java:</div><div class="line">Public void go(View view)&#123;</div><div class="line">Intent intent = new Intent(); //实例化intent</div><div class="line">//intent.setClass(this,SecondActivity.class); //“想找谁就找谁”，显式启动（不建议使用）</div><div class="line">Intent.setAction(“codding”);//隐式启动（建议使用）；</div><div class="line">//Intent.addCategory(Intent.CATEGORY_DEFAULT); //隐式启动隐含的代码</div><div class="line">表示找CATEGORY_DEFAULT分类下的codding（内容任意写）【在Manifests中配置】</div><div class="line">...  //可设置intent的其它属性，如intent.putExtra(“key”,”value”);可传递各种数据；startActivity(intent); </div><div class="line">&#125;</div><div class="line">SecondActivity.java:</div><div class="line">（在onCreate()方法中接收intent）</div><div class="line">Intent intent = this.getIntent();</div><div class="line">...  //获得各种数据如String uname = intent.getStringExtra(“uname”);</div><div class="line">...</div><div class="line">￭数据量较大时可新建一个类进行封装，该类实现序列化接口。在一端实例化该类并添加数据，在另一端用序列化类型接收（getSerializableExtra(“key”)）。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">eg2.（启动下一个Activity并获取返回结果）</div><div class="line">FirstActivity.java:</div><div class="line">...</div><div class="line">startActivityForResult(intent,12); //第二个参数为请求码（任意数字）</div><div class="line"> </div><div class="line">//在上述启动过的Activity执行结束时才会执行下面的回调方法</div><div class="line">Protected void onActivityResult(int requestCode,int resultCode,Intent data)&#123;</div><div class="line">//此处的intent为另一个Activity中的intent；由 requestCode,resultCode 确认关联关系</div><div class="line"> </div><div class="line">if(requestCode=12&amp;resultCode==11) </div><div class="line">Log.i(“标签” , data.getStringExtra(“msg”)); //进行调试</div><div class="line">&#125;</div><div class="line"> </div><div class="line">SecondActivity.java:</div><div class="line">Public void finish(View view)&#123;</div><div class="line">Intent intent = getIntent();</div><div class="line">intent.putExtra(“msg”,”内容”);</div><div class="line"> </div><div class="line">setResult(11,intent); //第一个参数为结果码（不同于请求码的任意数字）；第二个参数为上述SecondActivity操作后的intent，对应FirstActivity中回调方法参数的（Intent data）项。</div><div class="line"> </div><div class="line">finish(); //完成任务后结束</div><div class="line">&#125;</div><div class="line">补：在.xml定义EditText，添加id(如tvl); 之后在其Activitity中获得并查看其内容：</div><div class="line">TextView tvl = (TextView)findViewById(R.id.tv1); //TextView是View的子类，所以要强转。</div><div class="line">Tv1.getText().toString();</div></pre></td></tr></table></figure>
<p>1.Activity<br>1）类比Java中的Jsp（表现层）<br>2）Activity的栈式管理<br>3）Activity的生命周期</p>
<p>2.Service</p>
<ul>
<li>是APP组件之一，驻留于后台，类似Windows后台程序。运行于调用它的APP的进程的UI线程中，不会随着启动它的组件一并销毁。利用它可以实现IPC通信，不等同于“业务层bean对象”。</li>
<li>Service开发：<br>继承Service类，并Override生命周期方法【onCreate(),onStartCommand(),onDestroy()】。在清单文件中（注册）加以描述，并加入适当的intent-filter。Service是隐式启动，但无需加CATEGORY_DEFAULT，它只需加action即可（name=”MySer”），外界Activity通过该action就可以启动该Service。【方法如下：做一个启动按钮。须有一个intent找到相应的intent，<br>（Intent intent=new Intent(“MySer”)，然后startService(intent); 同理可以做一个按钮来杀死该Service】<br>启停方法：startService(intent);stopService(Intent)/stopSelf(); 【服务启动后不会自动停止，必须显示停止】; onStartCommand()（由安卓系统回调）;</li>
</ul>
<blockquote>
<p>￭开发实例（音乐播放器）：</p>
<ul>
<li>A. 做启停按钮（含启停方法）。在Activity中的onCreate()方法里实例化一个MediaPlayer的对象，之后在play()中首先需调用reset()和setDataSource(“/sdcard/mp3/a.mp3”)方法加载资源。<br>（此处需事先将mp3文件压入sdcard或storage/emulated下新建的一个mp3文件夹 ）。【setDataSource(String path)，此方法可从SD卡中加载资源，它还允许把一个网络资源的流（InputString） 加载到DataSource，即允许在线播放，边下边听和本地缓存等功能。】</li>
<li>B. 根据时序图，下一步是预备（prepare()）,再下一步是开始播放（start()）。给play()抛出异常即可。最后再写暂停方法（pause()）。</li>
<li><ul>
<li>￭在Activity中播放，将处于非UI子线程并且退出后音乐不停止，此时无法正常结束音乐。</li>
</ul>
</li>
<li><ul>
<li>￭在Service中播放，退出Activity虽无法停止音乐，但可以通过Service来控制音乐。<br>所以在此进一步考虑把播放器放入Service，便可通过Service杀死播放器后台进程。<blockquote>
<ul>
<li><ul>
<li>A. <code>新建一个Service。和前面相同，先在onCreate()方法里实例化一个MediaPlayer对象，在onStartCommand()里面控制播放器的播放，暂停，停止。而在相应Activity中则不再在onCreate()方法里实例化一个MediaPlayer对象，然后在play()和pause()方法中控制启停，此时play()和pause()方法用来告诉Servise做出相应动作，向其发送指令信息。</code></li>
</ul>
</li>
<li><ul>
<li>B. <code>在play()中通过intent发送信息（Intent intent = new Intent(“music”) ;//music表示动作）;需再进一步指明具体动作（intent.putExtra(“action”,1);//1代表播放指令，也可写PLAY,但应在开头事先声明：public static final int PLA Y = 1;）; 然后startService(intent)即可。</code></li>
</ul>
</li>
<li><ul>
<li>C. <code>同理在pause()中相应发送相应暂停指令即可。当然，除了play()和pause()方法，还可以有其它方法，通过它们发送指令信息。</code></li>
</ul>
</li>
<li><ul>
<li>D. <code>在新建的Service中的onStartCommand()方法里用swith()方法接收并处理Activity发送的指令信息。</code></li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">【（int action = intent.getIntExtra(“action”,-1);//第二参数表示接收不到值就显示-1），</div><div class="line">swith(action)&#123;</div><div class="line">   case MainActivity.PLAY :</div><div class="line">     拷贝原先Activity中play()方法的reset(),setDataSource(),prepare(),start()</div><div class="line">    //setDataSource(),prepare()处理异常即可</div><div class="line">break;</div><div class="line">   case MainActivity.PAUSE:</div><div class="line">     拷贝原先Activity中pause()方法</div><div class="line">break;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>★附：OnStartCommand的返回值：</p>
</blockquote>
<ul>
<li><code>OnStartCommand（Intent intent, int flags, int startid）{...}</code><br><code>//第一个参数是Activity传递过来的intent；OnStartCommand()可被反复调用，而第三个参数便是用来区分每次调用的编号；OnStartCommand有多种启动方式（如粘性启动和非粘性启动），第二个参数便是用来区分启动方式的。</code></li>
<li><code>OnStartCommand()方法不是startService()调用的而是安卓系统调用的，凡是on开头的方法都是回调方法，由安卓系统自动调用，startService()只是通知安卓系统去调用。</code></li>
</ul>
<blockquote>
<blockquote>
<p>★从音乐播放器开发实例中可进一步发现Service和Activity之间的关系：<br>Service掌管播放器所有事宜，而Activity只是承担命令发送者的角色，即接收用户请求，把该请求翻译成命令交给Service,然后由Service根据该命令做出不同动作。</p>
</blockquote>
<p>★附：IntentService()【为我们封装了多线程的内容，可在主线程中实现一次性启停一个子线程】<br>1）新建IntentService,因IntentService没写无参构造，需人为添加一个无参构造（调用带参构造）；之后重写onHandleIntent()方法。</p>
</blockquote>
<ul>
<li>★★★绑定Service</li>
</ul>
<blockquote>
<ul>
<li>A.主要应用于IPG通信。第一次被绑定时实例化，最后一个客户端解绑定时完成onUnbind和onDestroy，在一个进程中使用bind方式无实际意义。</li>
<li>B.它的使用以调用bindService()开始；onCreate()；onBind()（只有在第一次访问时调用一次，此处不同于先前的onStartCommand()随反复访问Service可以多次调用。）；onUnbind()（解绑后并不会马上回调，该Service运行期间可能有多个客户端或Activity来绑定它，只有所有的绑定Service都回调onUnbind()时，此处才会最后调用一次onUnbind()）；onDestroy()【此处无需finish()，所有客户端或Activity都解绑后自动调用，最后自动shut down。当然，该Service允许被其它Activity启动，并照常回调onStartCommand(),但如果它以onStartCommand()启动了，所有客户端解绑后它也不会Destroy(),需被finish()。<code>★即一个Service可以被启动和绑定，即startService()和bindService()。】</code></li>
</ul>
<blockquote>
<p>★由上述可见onBind()和onUnbind()都只调用一次，前者是第一个客户端绑定的时候回调一次，后者是最后一个客户端调用时它回调一次。</p>
</blockquote>
<ul>
<li>C.onBind()方法有一个返回值：IBinder（苹果公司发布的一个新产品）是一个接口，包含很多接口方法，为避免麻烦可写一个类（MyBinder）直接继承Binder（它已实现Ibinder），并增加自己的方法，然后在onBind()中实例化。</li>
<li>D.服务器端RmiService（onBind()）写完后在Manifests中注册（需加action（name=”rmi”））即可，然后再写客户端Activity（onCreate()方法或按钮对应的事件（方法））:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = new Intent(“rmi”);</div><div class="line">bindService(intent,new ServiceConnection,BIND_AUTO_CREATE);</div></pre></td></tr></table></figure>
<p><code>//第三个参数是指示器，指示如果另外一端的Service没启动该怎么办；第二个参数ServiceConnection，ServiceConnection仍然是一个接口，在此处可直接使用匿名内部类实现它【重写里面的抽象方法，其中onServiceConnected()方法里含有Ibinder代理对象(proxy)，其本质是另一端Rmi中的MyBinder的变身，（开头处声明）直接在此处强转即可：RmiService.MyBinder mybinder= (RmiService.MyBinder)proxy;
//此后便可由此代理对象获取另一端IBinder的传值。】</code></p>
<blockquote>
<p>应用：例如可用它完善前面的音乐播放器。</p>
<blockquote>
<p>【在Service端的play()方法里开一个子线程监控进度，在Activity端的play()方法里也开启一个子线程获取不断变化的progress,拿它更新SeekBar。】</p>
<ul>
<li>①定义并获取SeekBar，在play()方法里开启一个子线程，循环查找MyBinder里的progress（定期休眠和获取即可），并在主线程里实现更新（包装成Message，调用handler()）。</li>
<li>②Activity承担发送指令的角色，所以要在play(),pause(),resume()等方法中发送指令并启动Service（StartService()）。</li>
<li>③Service根据该指令做出不同动作（回调OnStartCommand()）。play(),pause(),resume()之间通过同步机制（Synchronized）实现通信。</li>
</ul>
<blockquote>
<p>★上述音乐播放器退出后，Activity开启的子线程仍在运行，说明在play()中开启子线程不合适，需进一步完善，分析可知将该子线程置于bindService()的onServiceConnected()里用于更新进度再合适不过了。<code>另外，Activity退出后，需杀死子线程，所以可增加条件：while（…&amp;&amp; isRun）//isRun表示判断是否运行。开头处声明正常情况下让isRun=true。</code><br><code>当Activity退出后,肯定要执行OnDestroy(),所以增加该回调方法,让isRun=false即可。</code></p>
</blockquote>
</blockquote>
<ul>
<li>E. 当Activity用完之后则进行解绑（调用onUnbind()）。</li>
</ul>
</blockquote>
<p>3.ContentProvider</p>
<blockquote>
<p>＊主要用来做数据存储，实际上它自身并不提供存储机制，而是一个中间抽象层（中间件）。<br>Activity，Service，BroadcastReceiver 三大组件之间通过Intent连接，而ContentProvider则是通过URI连接。</p>
<ul>
<li>它是Android数据共享标准（区分与RDBMS），也是Android的组件之一（需要注册）。</li>
<li>它由开发者继承并重写其CURD的方法，注册后暴露其URI，即一系列的URI对应到相应的CURD方法。</li>
<li>其URI符合Result风格，统一了数据共享的API操作，即屏蔽了内部对文件和数据库等一系列操作的不同，APP的开发者只需要关注Android所提供的API即可。</li>
<li>其访问的URI规则如下：<blockquote>
<ul>
<li>a.Scheme: ContentProvider的scheme已经由Android所规定为：content://</li>
<li>b.主机名（或Authority）: 用于唯一标识这个ContentProvider（即包名）</li>
<li>c.路径（path）: 可以用来表示我们要操作的数据，路径的构建应根据业务而定，如下：<br>要操作contact表中id为10的记录，可以构建这样的路径：/contact/10<br>要操作contact表中id为10的记录的name字段，可以构建路径：/contact/10/name<br>要操作contact表中的所有记录，可以构建这样的路径：/contact</li>
</ul>
</blockquote>
</li>
</ul>
<blockquote>
<ul>
<li>ContentProvider开发：<blockquote>
<ul>
<li>新建类(如TigerContentProvider)继承ContentProvider复写其CURD方法。</li>
<li>注册:（exported=”true”,authorities=”tiger1.cn”,name=”.TigerContentProvider”）</li>
<li>增加按钮(做查询)和对应事件（方法），方法中不可能直接去实例化TigerContentProvider（因为组件及其实例化是由安卓系统管理的）， 但可以实例化getContentResolver() ,<br><code>（ContentResolver resolver=getContentResolver()）,它相当于ContentProvider客户端，里面含有CURD方法，通过对这个resolver进行增删改查的动作，然后它会命令Android系统回调TigerContentProvider里面的增删改查，即间接实现CURD方法。（使用解耦合）</code></li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">eg1.(查询)</div><div class="line">public void query(View view)&#123;</div><div class="line">Uri uri = Uri.parse(“content://tiger1.cn”);</div><div class="line">//此处为URI连接协议，主机名（或Authority）对应先前注册的authorities</div><div class="line">ContentResolver resolver=getContentResolver();</div><div class="line">Cursor cs = resolver.query(uri,null,null,null,null);</div><div class="line">//参数分别为uri,投影，选择，排序；null表示没有；结果返回一个Cursor,可对其操作。</div><div class="line">&#125;</div><div class="line">＊应用：对电话簿的ContentProvider的访问</div></pre></td></tr></table></figure>
<p>4.BroadcastReceiver<br>1）进行广播</p>
<h3 id="八．★★安卓多线程"><a href="#八．★★安卓多线程" class="headerlink" title="八．★★安卓多线程"></a>八．★★安卓多线程</h3><ul>
<li>安卓中，在子线程里更新UI组件会报错；而在UI线程里调用网络连接会报错，强制性要求只能在子线程中调用。（这是利用安卓的框架自身来保证代码的正确性）</li>
<li>多线程处理机制（线程间通信）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">eg1.</div><div class="line">public class MainActivityextends AppCompatActivity &#123;</div><div class="line">    private TextView tv;</div><div class="line">    private Handler handler;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123; //UI线程</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        tv = (TextView)findViewById(R.id.tv);</div><div class="line">        sb = (SeekBar)findViewById(R.id.sb);</div><div class="line">        handler=new Handler() &#123;</div><div class="line">//UI线程绑定一个Handler,可监听Massage对象。handler中有消息队列（MessageQueen）。</div><div class="line">  注：子线程也可以绑定Handler，即反过来在UI线程中包装Message，在子线程中改变相应的值。</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;//复写回调方法，在主线程中更新UI</div><div class="line">                int i = msg.getData().getInt(&quot;pro&quot;);</div><div class="line">                tv.setText(&quot;test:&quot;+i);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    public void start(View view) &#123;</div><div class="line">    new Thread()&#123;</div><div class="line">        @Override</div><div class="line">        public void run() &#123;</div><div class="line">            for(int i=0;i&lt;101;i++)&#123;</div><div class="line">                try &#123;</div><div class="line">                    Thread.sleep(20);</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                    e.printStackTrace();</div><div class="line">                &#125;</div><div class="line">                //把上面的进度包装成一个消息</div><div class="line">                Message msg = new Message();</div><div class="line">                Bundle bundle = new Bundle();</div><div class="line">                bundle.putInt(&quot;pro&quot;,i);</div><div class="line">                msg.setData(bundle);</div><div class="line">                //把消息发到消息队列中，发100次</div><div class="line">                handler.sendMessage(msg);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">eg2.(在主线程中干预子线程的运行&gt;&gt;Synchronized , wait , notify)</div><div class="line">在eg1基础上增加SeekBar,pause,resume按钮和相应事件（方法），在子线程中设置运行条件，而在主线程中控制条件即可。</div><div class="line">public class MainActivity extends AppCompatActivity &#123;</div><div class="line">    private TextView tv;</div><div class="line">    private Handler handler;</div><div class="line">    private SeekBar sb;</div><div class="line">    private boolean isPause=false;</div><div class="line">    @Override</div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line">        tv = (TextView)findViewById(R.id.tv);</div><div class="line">        sb = (SeekBar)findViewById(R.id.sb);</div><div class="line">        handler=new Handler() &#123;</div><div class="line">            @Override</div><div class="line">            public void handleMessage(Message msg) &#123;</div><div class="line">                int i = msg.getData().getInt(&quot;pro&quot;);</div><div class="line">                tv.setText(&quot;test:&quot;+i);</div><div class="line">                sb.setProgress(i);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    public void start(View view) &#123;</div><div class="line">        new Thread()&#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                synchronized (handler) &#123;</div><div class="line">//这把锁在主线程和主线程中都是共用的，其中的对象是二者皆可见的唯一对象，否则wait()调用处无效。此处选择Handler作为共用对象更为合适。</div><div class="line">MainActivity自身可做锁对象。但此处不能用public Synchronized void  run()&#123;…&#125;，因为此处用的是子线程对象，况且run()方法里面没有Synchronized，它是复写的，所以此处只能用同步代码块。</div><div class="line"> // 另外，wait()和notify()配套使用，且二者被调用时要求必须处于一个同步代码块的内部（Synchronized）,还要求其调用对象必须是同步代码块中的那个同步锁。</div><div class="line">                    for (int i = 0; i &lt; 101; i++) &#123;</div><div class="line">                        if (isPause) &#123;</div><div class="line">                            try &#123;</div><div class="line">                                handler.wait();</div><div class="line">                            &#125; catch (InterruptedException e) &#123;</div><div class="line">                                e.printStackTrace();</div><div class="line">                            &#125;</div><div class="line">                         &#125;</div><div class="line">                        try &#123;</div><div class="line">                            Thread.sleep(20);</div><div class="line">                        &#125; catch (InterruptedException e) &#123;</div><div class="line">                            e.printStackTrace();</div><div class="line">                        &#125;</div><div class="line">                        Message msg = new Message();</div><div class="line">                        Bundle bundle = new Bundle();</div><div class="line">                        bundle.putInt(&quot;pro&quot;, i);</div><div class="line">                        msg.setData(bundle);</div><div class="line">                        handler.sendMessage(msg);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;.start();</div><div class="line">    &#125;</div><div class="line">    public void pause(View view) &#123; isPause=true;  &#125;</div><div class="line">/*  public synchronized void resume(View view) &#123; //将MainActivity自身作为锁对象</div><div class="line">        isPause=false;</div><div class="line">        notify(); &#125;*/</div><div class="line">    public synchronized void resume(View view) &#123; //此处用MainActivity锁对象自身</div><div class="line">        synchronized (handler)&#123;</div><div class="line">            isPause=false;</div><div class="line">            handler.notify();//唤醒，让其重新进入线程调用机...</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="九．安卓数据存储策略"><a href="#九．安卓数据存储策略" class="headerlink" title="九．安卓数据存储策略"></a>九．安卓数据存储策略</h3><blockquote>
<p>毕竟安卓系统不是做服务器的，在安卓系统中，数据库只是一个很小的范围，它并不认为数据一定要保存在数据库里，它只要能把数据存储到某个地方即可。</p>
</blockquote>
<p>1.文件系统（首选）</p>
<blockquote>
<blockquote>
<p>File存储：<br>原理：使用一个普通自定义文件做为存储媒介，以流的方式进行读写操作。</p>
</blockquote>
</blockquote>
<ul>
<li><code>OutputStream out = context.openFileOutput(fileName,mode);</code><br> //此方法打开<data packname="" files="" filename="">的输出流；Mode可以是MODE_PRIVATE|MODE_APPEND（前者为默认操作模式，代表该文件是私有数据,只能被应用本身访问,在该模式下,写入的内容会覆盖原文件的内容。后者为最佳模式，会检查文件是否存在,存在就往文件追加内容,否则就创建新文件。）等。其中按位或|可做权限叠加。</data></li>
<li><code>Inputstream in = context.openFileInput(fileName);</code></li>
<li>常用方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">File getFileDir[];//获取data/packName/files的目录对象；</div><div class="line">File getDir[dirName,mode];</div><div class="line">String[] fileList[];</div><div class="line">deleteFile[fileName];</div><div class="line">注：上述方法无需new File()（需找文件路径），文件存储在data/packName/files下。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eg1.(存储)</div><div class="line">OutputStream out = openFileOutput(“tiger.data”,MODE_PRIVATE|MODE_APPEND);</div><div class="line">//out.write(“Hello World!”.getByte());</div><div class="line">  out.write(“Hello World!,世界你好”.getByte(“UTF-8”));</div><div class="line">★补：Java中一般不会使用字符流，即reader和writer，因为它不能设定文字编码，它是自动转码的，我们没办法随心所欲地控制它。</div><div class="line">out.close();//流要自己管理，此处需手动关闭</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">eg2.（取出）</div><div class="line">Inputstream in = openFileInput(“tiger.data”);</div><div class="line">byte[] buf = new byte[4];//在内存中开辟一个缓存读取文件,此处按一次4个字节读取</div><div class="line">/* int count=0;</div><div class="line">while(count=in.read(buf)!=-1)&#123;</div><div class="line">//此处可用来边读边写</div><div class="line">&#125;  */</div><div class="line">byte[] buf = new byte[in.available()];//此处一次性读取</div><div class="line">in.read(buf);</div><div class="line">String msg = new String(buf,”UTF-8”);//此处将buf重新编码成UTF-8</div><div class="line">Log.i(“tiger”,msg);</div><div class="line">in.close();</div><div class="line">＊附：加大难度写一个对象进去，这是纯Java的知识，把上述流包装成对象流即可：</div><div class="line">ObjectoutputStream oout = new ObjectOutputStream(out);</div><div class="line">oout.write(new Object());</div></pre></td></tr></table></figure>
<blockquote>
<p>★★附：SharedPreferences存储</p>
<blockquote>
<p>原理：由保存在data/data/<packname>/shared_prefs/xxx.xml完成数据的存储。<br>实际上SharedPreferences用的是map(key-value)键值对存储，它是轻量级存储，常用来存储一些轻量级数据。其底层仍然用inputStream和outputSteam，但是其上层API看不见这些，它的存储不需要考虑流的问题。</packname></p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">eg1.(存储)</div><div class="line">定义SharedPreferences pref，在onCreate()方法中得到它：</div><div class="line">（pref = PreferenceManager.getDefaultSharedPreferences(this);）</div><div class="line"> Set &lt;String&gt; set = new HashSet&lt;String&gt;();</div><div class="line">   set.add(“basket”); set.add(“foot”);</div><div class="line">   SharedPreferences.Editor editor = pref.edit(); //存储需借助Editor</div><div class="line">   editor.putString(“uname”,”tiger”);editor.putInt(“age”,100);</div><div class="line">   editor.putStringSet(“sport”,set); //可存储集合数据 </div><div class="line">   editor.commit(); // 此前的操作都在内存,通过commit()存储</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">eg2.（取出）</div><div class="line">String uname = pref.getString(“uname”,”xxxxx”);//第二参数为默认值,以下同理</div><div class="line">int age = pref.getInt(“age”,-1);</div><div class="line">Set&lt;String&gt; sport = pref.getStringSet(“sprot”,null);</div><div class="line">Log.i(“tiger”uname+”...”+age);</div><div class="line">for(String key:sport)&#123;</div><div class="line">Log.i(“tiger”,key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>注：上述存储过程可不断被覆盖，适合存储进度。<br>附：File存储不适合变动数据的存储，数据库系统更优，它适合增删改查</p>
</blockquote>
</blockquote>
<p>2.数据库系统</p>
<blockquote>
<p>标准方案：使用jdbc的jar包连接数据库进行存储，不过使用概率小。</p>
<blockquote>
<p>★安卓自身存储方案：只针对一种数据库：SQLite</p>
</blockquote>
</blockquote>
<p>SQLite是Linux底层的一个非常轻量级的基于文件（一个文件即一个db，区别于Oracle：非文件型，一个db实例包含多个文件）的关系型数据库，支持SQL92，海量存储，并发，性能，安全方面较弱，但体积小，开销低，较适合用于便携及嵌入式设备。</p>
<blockquote>
<p>1）* SQLite数据类型(比较少):NULL(空值)，INTEGER(整型)，REAL(实数型//浮点数字)，TEXT(字符串文本),BLOB(二进制对象)</p>
<p>2）* ★SQLite的核心对象：SQLiteDatabase</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">  获取方式：SQLiteDatabase.openDatabase(...)//打开现有的数据库</div><div class="line">                          .openOrCreateDatabase(...)//打开或创建数据库</div><div class="line">  使用方式：.execSQL()//执行更新类操作；.rawQuery()//执行查询，返回Cursor对象</div><div class="line">            .close()//关闭</div><div class="line">＊注：Cursor（和jdbc核心对象中的Resulset是同一类对象）</div><div class="line">            .moveToNext()//如果有下一条记录返回true，否则返回false</div><div class="line">            .getXXX(index)//返回查询到的某个Index列的数据，index从0开始。</div></pre></td></tr></table></figure>
<blockquote>
<blockquote>
<p>★SQLiteDatabase使用方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">实例化一个对象SQLiteDatabase db，在onCreate()方法中用工厂方法打开或创建数据库：</div><div class="line">db = SQLiteDatabase.openOrCreateDatabase(“tiger.data”，null);</div><div class="line">//第一个参数是文件路径； 第二个参数是CursorFactory,里面有一个回调器，可供查询后处理遍历问题。这样的好处是把对Corsor的处理封装到对象中去。此处null表示不使用。</div><div class="line">注：此处tiger.data不在项目目录下而存储在用户根目录下，我们最好将其存储在外存上（需开放相应权限）。</div></pre></td></tr></table></figure></p>
<p>★附：Sdcard的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">可使用Environment.getExternalStorageState()：获取是否挂载的信息（即是否有外存）；</div><div class="line">File Environment.getExternalStorageDirectory():获取Sdcar的挂载点，返回File文件。</div><div class="line">需加入（权限）：</div><div class="line">&lt;user-permission android:name=”android.permission.MOUNT_UNMOUNT_FILESYSTEMS”&gt;</div><div class="line">&lt;user-permission android:name=”android.permission.WEITE_EXTERNAL_STORAGE”/&gt;</div></pre></td></tr></table></figure></p>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eg1.(创建db)</div><div class="line">File sdcardPath = Environment.getExternalStorageDirectory();</div><div class="line">db=SQLiteDatabase.openOrCreateDatabase(“sdcardPath.getAbsolutePath()</div><div class="line">+”/tiger.data”，null); //db的生成</div><div class="line">创建表：定义按钮，可在其对应事件（方法）内创建表（String ddl=“create table users(_id interger primary key autoincrement,uname text)”;db.execSQL(ddl);）</div><div class="line">存取数据：</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">eg2.(存储)</div><div class="line">String sql=”insert into users (uname) valus (?)”</div><div class="line">Try&#123; //支持事务</div><div class="line">db.beginTransaction();</div><div class="line">//db.execSQL(sql);//抛异常时下行代码不执行，直接回滚</div><div class="line">db.execSQL(sql,new Object[]&#123;“tiger”+i++&#125;);</div><div class="line">//在开头声明变量i并初始化为0，此处表示点击一次加一次</div><div class="line">db.setTransactionSuccessful();</div><div class="line">&#125;catch(Exception e)&#123;</div><div class="line">&#125; finally&#123; db.endTransaction(); //必须结束事务 &#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">eg3.（取出/查询）</div><div class="line">String sql=”select id,uname from users where id&gt;?”</div><div class="line">//强烈建议不要使用seclect * from ...</div><div class="line">Cursor cs= db.rawQuery(sql,new String[]&#123;“2”&#125;);</div><div class="line">//第二参数表示条件（id&gt;2）,是由于API设计时规定其它类型在此都变成String类型</div><div class="line">while (c.moveToNext())&#123;</div><div class="line">String uname = c.getString(1);</div><div class="line">//此处1对应select语句中的uname,如果上述代码使用seclect * from，则无此对应顺序。</div><div class="line">int id=cs.getInt(cs.getColumnIndex(“_id”));</div><div class="line">//参数可以写0，它仍保留使用字段名的方式，但明显麻烦。</div><div class="line">Log.i(“tiger”,uname+”...”+id); &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>3）★上述数据库存储中还存在其它问题，安卓系统不允许二次创建（覆盖）表格，况且app升级一般会涉及数据库结构更新，因此需要另一个SQLite的核心对象：SQLiteOpenHelper：会自动处理数据库的第一次创建，结构更新等操作的工作类型.(帮助完成初始化和升级)需要override其onCreate(),onUpgrade()等方法.</p>
<p>★SQLiteOpenHelper使用方法：<br>新建类(如TigerOpenHelper)继承SQLiteOpenHelper，实现其onCreate()，onUpgrade()。</p>
<blockquote>
<p>注：SQLiteOpenHelper没有无参构造，新建的类需添加SQLiteOpenHelper的带参构造，并在其中调用super(context,name,factory,version);</p>
<blockquote>
<p>￭onCreate()代码段只有在第一次利用此类获得database时才执行。</p>
</blockquote>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eg1. onCreate(...)&#123;</div><div class="line">//可去除先前创建表的按钮和对应事件（方法）。把创建表的代码移到此处，实现自动建表。</div><div class="line">&#125;</div><div class="line">在原来使用SQLiteDatabase的基础上，在Activity里实例化一个TigerOpenHelper对象TigerOpenHelper helper，在onCreate()方法中实例化helper并获得数据库：</div><div class="line">helper=new TigerOpenHelper(this,sdcardPath.getAbsolutePath()+”/tiger1.data”，null,1); // 版本号1对应onUpgrade()中的oldVersion，本号加1则表示升级下一个版本，升级时onCreate()不会执行而执行onUpgrade()，不升级时相反。</div><div class="line">db=helper.getWritableDatabase();//可写包含可读功能</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eg2. onUpgrade(...)&#123;</div><div class="line">//结构变化代码</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>WebService</li>
</ol>
<blockquote>
<p>在安卓系统中安装一些WebService标准的API，调用这些API时自动连接网络存储数据。</p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/25/核心Java/" itemprop="url">
                  核心Java
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-25T00:00:00+08:00" content="2016-04-25">
              2016-04-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程基础/" itemprop="url" rel="index">
                    <span itemprop="name">编程基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一：WebUI"><a href="#一：WebUI" class="headerlink" title="一：WebUI"></a>一：WebUI</h3><h3 id="二-JAVA"><a href="#二-JAVA" class="headerlink" title="二:  JAVA"></a>二:  JAVA</h3><h3 id="三：oracle"><a href="#三：oracle" class="headerlink" title="三：oracle"></a>三：oracle</h3><h3 id="四-JavaWeb-J2ee"><a href="#四-JavaWeb-J2ee" class="headerlink" title="四:  JavaWeb, J2ee"></a>四:  JavaWeb, J2ee</h3><p>1.框架：</p>
<ul>
<li>Hibernate:（xml版）</li>
<li>框架搭建：</li>
</ul>
<p>2015.12.30<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">String和StringBuffer的区别：示例：</div><div class="line">Private String randName(int len)&#123;</div><div class="line"> </div><div class="line">String s= “hello”;</div><div class="line">s=”abc”;</div><div class="line"> </div><div class="line">StringBuffer sb = new StringBuffer();</div><div class="line">For(int i = 0; i&lt;len;i++)&#123;</div><div class="line">s += (char)(Math.random()*26+65)</div><div class="line">sb.append((char)(Math.random()*26+65));</div><div class="line">//产生随机大写字母（对应数字65~90，小写对应数字97~122）</div><div class="line">&#125; </div><div class="line">Return sb.toString();//StringBuffer要通过toString()转换成String</div><div class="line">&#125;</div><div class="line">上面的两个s指向两个不同地址+=后把两个地址合并后放入一个新地址，即一直在切换地址。</div><div class="line">s放在堆内存中，java中GC机制会自动回收(影响性能)，而在c++中没有回收机制，使用时要进行释放，否则会造成内存溢出。</div><div class="line"> </div><div class="line">double后面小数点保留15位，float后面小数点保留6位 </div><div class="line">若要取小数点后两位则有：</div><div class="line">1)用DecimalForamt 类进行数据格式转换</div><div class="line">DecimalForamt  df = new DecimaForamt(“#0.00”) //括号里指明格式</div><div class="line">String sd = df.format(Math.random()*100 )</div><div class="line">2）用Stirng类的fomat静态方法</div><div class="line">String sd = Stirng.format(“%.2f”,Math.random()*100)</div><div class="line"> </div><div class="line">Hibernate中分页代码：</div><div class="line">String hql =”from Book”;</div><div class="line">int pageSize=4;</div><div class="line">int currentPage = 1;</div><div class="line">int records = 0;</div><div class="line">int totalpage = 0;</div><div class="line">Quetry query = session.createQuery(hql);</div><div class="line">records = query.list.size();</div><div class="line">query.setMaxResults(pageSize);</div><div class="line">query.setFirstResult((currentPage-1)*pageSize);</div><div class="line">totalPage = records/pageSize;</div><div class="line">if(records%pageSize!=0)&#123;</div><div class="line">totalPage++;</div><div class="line">&#125;</div><div class="line">System.err.println(totalPage);//err（区别于out）：标记分页</div></pre></td></tr></table></figure></p>
<p>2016.1.02<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">文件上传（用户管理系统头像上传）：</div><div class="line"></div><div class="line">表单（二进制提交）取出字段用getFieldName()不能用request.getParameter()</div></pre></td></tr></table></figure></p>
<p>2016.1.03<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">计算机编码主要区分：</div><div class="line">ASCLL：英文编码。其中ISO-8859-1是ASCLL码的一个子集。</div><div class="line">Unicode:中文编码 （除英文外的其他语言用的编码）。</div><div class="line">UTF-8：是Unicode的一个分支。</div><div class="line">gbk:是UTF-8的一个分支。(big5（大五码/繁体中文，也是UTF-8的一个分支)。</div><div class="line">gb2312:是gbk的子集。</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">编码存储：</div><div class="line">ASCLL（255个字符，122后就是乱码）：字节存储（1byte=8bit），一个字节表示一个英文字母。大写字母A~Z（65~90），小写字母a~z（97~122）。数字编码0~9（48~57），其它符号如13表示空格。。。</div><div class="line">Unicode（0~65535）:2byte=16bit</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">中文乱码：</div><div class="line">（1）Get提交（URL重写）： </div><div class="line">Tomcat7 修改配置文件（server）在容器connector中的端口后加URIEncoding=”UTF-8”。</div><div class="line">Tomcat8无需修改配置文件可直接处理get提交的中文乱码。</div><div class="line">（2）post提交</div><div class="line">源程序中添加： </div><div class="line">String tex = request.getParameter(“text”);</div><div class="line">Text=new String(text.getBytes(“ISO-8859-1”),”UTF-8”); </div><div class="line">或源程序中添加：request.setCharacterEncoding(“UTF-8”)；//控制器中表单采用二进制（字节）提交时不起作用。若数据库存储依然乱码，需统一数据库编码，要在数据库连接处告诉数据库采用何种编码（？useUnicode=true&amp;characterEncoding=UTF8)。（oracle一般能自动统一数据库编码） </div><div class="line">（3）输出到浏览器乱码：response.getWriter().print(text);</div><div class="line">源程序中添加: Response.setContentType(“text/html,;charset-UTF-8”);//设置的是响应头或请求头不是设置输出文件。</div></pre></td></tr></table></figure>
<p>2016.1.06<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">java读取属性文件</div><div class="line">1.</div><div class="line">例一（读取系统属性）</div><div class="line">Properties p = System.getProperties();//导入uitil工具包</div><div class="line">p.list(System.out);/、获取所有的属性</div><div class="line">System.out.println(p.getProperty(“os.name”));//获取单个属性</div><div class="line"> </div><div class="line">2.例二（连接池动态加载）</div><div class="line">写配置文件(driver,url；不加引号)，并定义类变量driver,url</div><div class="line">在源程序中添加代码（如init（）方法中）： </div><div class="line">Properties p  = new Properties();</div><div class="line">//获取类的存放目录（用类反射）</div><div class="line">String path = 类名.class.getResource(“/属性文件名”).toString().substring(6);</div><div class="line">InputStream in = new FileInputStream(new File(“path”));</div><div class="line">p.load(in);</div><div class="line">driver = p.getProperty(“driver”);</div><div class="line">url  = p.getProperty(“url”)</div><div class="line">``` </div><div class="line">2016.01.14</div></pre></td></tr></table></figure></p>
<p>UserDAOImpl.java:<br>public class UserDAOImpl extends HibernateDaoSupport implements UserDAO{</p>
<p>Public void delete(long id){<br>Session session = getSession();<br>Obeject o = Session.get(User.class,id);<br>//用get,记录不存在就返回空；<br>Obeject o = Session.load(User.class,id);<br>//用load,没有记录的话，会抛异常，程序终止，后面不再执行，确定存在记录则可大胆使用<br>session.delete(o);<br>  }<br>}<br>```</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/23/Java多线程/" itemprop="url">
                  Java多线程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-23T00:00:00+08:00" content="2016-04-23">
              2016-04-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程基础/" itemprop="url" rel="index">
                    <span itemprop="name">编程基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h4><ul>
<li><p>同步：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；</p>
</li>
<li><p>异步：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。</p>
</li>
</ul>
<p><em>代码示例</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</div><div class="line">       </div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</div><div class="line">       </div><div class="line">  &#125;</div><div class="line">   </div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">      fun1();</div><div class="line">      fun2()</div><div class="line">      .....</div><div class="line">      .....</div><div class="line">  &#125;</div><div class="line"></div><div class="line">这段代码就是典型的同步，在方法function中，fun1在执行的过程中会导致后续的fun2无法执行，fun2必须等待fun1执行完毕才可以执行。</div><div class="line">　　接着看下面这段代码：</div><div class="line">	</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123;</div><div class="line">     </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123;</div><div class="line">     </div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            fun1();</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line">     </div><div class="line">    <span class="keyword">new</span> Thread()&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            fun2();</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div><div class="line"> </div><div class="line">    .....</div><div class="line">    .....</div><div class="line">&#125;</div><div class="line">这段代码是一种典型的异步，fun1的执行不会影响到fun2的执行，并且fun1和fun2的执行不会导致其后续的执行过程处于暂时的等待。</div></pre></td></tr></table></figure></p>
<blockquote>
<p> 事实上，同步和异步是一个非常广的概念，它们的重点在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。我觉得可以将同步和异步与Java中的synchronized关键字联系起来进行类比。当多个线程同时访问一个变量时，每个线程访问该变量就是一个事件，对于同步来说，就是这些线程必须逐个地来访问该变量，一个线程在访问该变量的过程中，其他线程必须等待；而对于异步来说，就是多个线程不必逐个地访问该变量，可以同时进行访问。</p>
<p> 因此，个人觉得同步和异步可以表现在很多方面，但是记住 <strong>其关键在于多个任务和事件发生时，一个事件的发生或执行是否会导致整个流程的暂时等待。</strong> 一般来说，可以通过多线程的方式来实现异步，但是千万记住不要将多线程和异步画上等号，异步只是宏观上的一个模式，采用多线程来实现异步只是一种手段，并且通过多进程的方式也可以实现异步。</p>
</blockquote>
<ul>
<li><p>阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；</p>
</li>
<li><p>非阻塞就是：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。</p>
</li>
</ul>
<blockquote>
<p>这就是阻塞和非阻塞的区别。也就是说<br><strong>阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。</strong></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/22/数据结构要点笔记/" itemprop="url">
                  数据结构要点笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-22T00:00:00+08:00" content="2016-04-22">
              2016-04-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程基础/" itemprop="url" rel="index">
                    <span itemprop="name">编程基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章   预备知识"></a>第一章   预备知识</h3><h4 id="一．对象与指针的关系"><a href="#一．对象与指针的关系" class="headerlink" title="一．对象与指针的关系"></a>一．对象与指针的关系</h4><ol>
<li>程序=数据结构+算法</li>
<li>一个指针只能装某一个对象的地址，不能指向两个三个或多个对象。指针可以不指向任何对象，即空指针，值为NULL。</li>
<li>一个对象可以有多个或零个指针指向它，如果一个对象没有任何一个指针指向它，该对象就无法访问和使用，称它为垃圾对象。</li>
</ol>
<h4 id="二．对象的内存表示"><a href="#二．对象的内存表示" class="headerlink" title="二．对象的内存表示"></a>二．对象的内存表示</h4><ol>
<li>对象=数据+方法（逻辑上的认识）</li>
<li>内存中对象包含的内容(涉及到它占用多大内存的问题)<br>类类型对象：<code>(eg. int x)</code><br>静态数据区：<code>(eg. static int y)</code><br>方法区: 普通方法+静态方法</li>
<li>(继承关系中)一个对象可以被当作任何它的祖先类型来对待，正因为对象存储的这个特点，才很方便的支持了多态的效果）。</li>
</ol>
<h4 id="三．串的内存表示"><a href="#三．串的内存表示" class="headerlink" title="三．串的内存表示"></a>三．串的内存表示</h4><ol>
<li>串是Java中最常用的类，也是Java特殊对待的类型之一，另一个是数组。</li>
<li>串是定常的，它的内容一经创建就不可改变。</li>
<li>Java中(字面)常量串存储在特殊的位置：串池中，★串池的特点是不允许重复和删除它的内容。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">eg1. (串对象用引号括起来)</div><div class="line">String a = ”abc”</div><div class="line">String b = ”bac”</div><div class="line">//a和b这两个指针(引用)的值现在是相等的。</div><div class="line">String c = ”ab”+”c”</div><div class="line">//Java在编译时会把ab加这样的表达式直接替换为abc，所以此操作与上一句效果相同，即c指针也是指向串池中哪个唯一的abc对象。</div><div class="line">String d = new String(a)</div><div class="line">//此语句与前面都不同，它是以a为参数在堆空间中创建对象，至于它的内容与Java的实现有关。</div><div class="line">a = a+x</div><div class="line">/a指针指向新创建的串对象”abcx”,原来所指向的对象没有指针指向它变为垃圾对象，由Java回收机制回收。但请注意：串池中的x对象是不会被回收，★因为串池具有这样的特点：其中的对象没有任何指针指向它，它也不会变为垃圾对象，不会被回收。</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">eg2.</div><div class="line">//String s = “”;</div><div class="line">StringBuilder sb = new StringBuilder();</div><div class="line">For(int i =0,i&lt;100,i++)&#123;</div><div class="line">//s = s + i ;</div><div class="line">sb.append(i)</div><div class="line">&#125;</div><div class="line">String s = sb.String();</div><div class="line">System.out.prinntln(s);</div><div class="line">&#125;</div><div class="line">上述代码段中，使用StringBuilder比String效率高得多，前者只需要创建一个对象，后者中途创建很多对象浪费掉了。</div></pre></td></tr></table></figure>
<h4 id="四．数组的内存表示"><a href="#四．数组的内存表示" class="headerlink" title="四．数组的内存表示"></a>四．数组的内存表示</h4><ol>
<li>数组在Java中也是一个特殊对待的类型。一个数组中的所有元素总是要占据一片连续的内存空间。数组长度在创建以后就固定了，无法修改。（因为数组尾部可能有其它对象存储，扩展数组空间会破坏后面对象的空间）</li>
<li>数组在随机访问时速度很快，因为每个数组都占用了同样大小的内存空间，我们可方便的计算出任何一个元素在内存中的位置。然而数组结构的插入和删除操作却十分吃力的。</li>
<li>自定义My类<br><code>eg. My[ ] a = new My[5]</code><br>a指针指向数组对象，而数组中的5个元素并非是关于对象的数组， 而是关于指针的的数组，在数组中包含了5个<code>My</code>类型的指针，初始值为<code>NULL</code>,即空指针。让<code>a[1]=new My( )</code> ，这样才能够创建新的<code>My</code>类型的对象，并且把它的地址存入a1这一单元中。<br>结论：数组对象是不能够包含其它任何对象的，事实上，我们可以说任何一个对象都不能在它的内存中包含另一个对象，它充其量只能包含其它对象的指针。</li>
</ol>
<h4 id="五．多态的实现"><a href="#五．多态的实现" class="headerlink" title="五．多态的实现"></a>五．多态的实现</h4><blockquote>
<p>是面向对象的精华，它可实现抽象地概括地去编码，运行时自动去匹配的效果，符合人类思考习惯。使用多态可以降低当需求变动时我们对类必须修改的可能性。实际上Java中绝大多数方法的调用都是多态的，即Java在编译期间并不能够确定应该调用哪个方法，而是在运行时根据对象的信息来自动查找到要调用的方法。</p>
<ol>
<li>继承关系中(C类继承B类，B类继承A类)<br><code>eg. A a = new C( ) ; //指针的类型和它指向的对象的类型并不是完全一致的，称之为指针泛化。</code><br>★在A类和B类中添加f( )方法，调用<code>a.f( )</code>,</li>
</ol>
<p>如上所述，Java根据对象中提供的信息去动态的查找到某一个方法。<br>内存中的一个对象总是要有这样一个字段包含这样一个信息，它含有一个指针，该指针指向了该对象的类型信息对象。每一个类都会对应唯一的一个类型信息对象，保存了该类的很多有用信息，例如它还包含了该类的父类型信息指针。<br>所以，当我们拿到指针后，找到了对象，仍然可以判定当初创建这个对象的类型是哪一个类。通过它的类型信息指针和其父类型信息指针来自动查找到要调用的方法。我们在类型信息对象中并不会去存储方法的代码(仍存储在方法区)，仅仅是存储了方法的名字和它们的一些位置信息或一些属性信息，我们根据这些信息找到了方法的位置，仍然是去方法区执行该方法。</p>
</blockquote>
<h3 id="第二章-自定义结构"><a href="#第二章-自定义结构" class="headerlink" title="第二章   自定义结构"></a>第二章   自定义结构</h3><h4 id="一．单链表的实现"><a href="#一．单链表的实现" class="headerlink" title="一．单链表的实现"></a>一．单链表的实现</h4><ol>
<li>单链表和数组一样也是一种线性结构，它可以克服数组弱点。</li>
<li>单链表每个单元都含有两项数据，一项数据用来存储元素本身，而另一个是指针（指向与自己类似的另一个对象）。</li>
<li>链表的关键点在于每个单元并不需要连续存储，前后单元没有物理上的位置关系，内存分配比较灵活。链表的插入删除操作很方便，只需修改指针。</li>
<li>单链表的缺点是它的随机访问很慢。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">eg. 链表的使用（插入操作）：</div><div class="line">class Mylist &#123;</div><div class="line">    private int data;</div><div class="line">    private Mylist next;</div><div class="line"> </div><div class="line">    public Mylist(int x) &#123;</div><div class="line">       data = x;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void add(Mylist x) &#123;</div><div class="line">       x.next = next;</div><div class="line">       next = x;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void append(Mylist x) &#123;</div><div class="line">       Mylist p = this;</div><div class="line">       while (p.next != null) &#123;</div><div class="line">           p = p.next;</div><div class="line">       &#125;</div><div class="line">       p.next = x;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void show() &#123;</div><div class="line">       Mylist p = this;</div><div class="line">       while (p != null) &#123;</div><div class="line">           System.out.println(p.data);</div><div class="line">           p = p.next;</div><div class="line">       &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Test01&#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">       Mylist head = new Mylist(10);</div><div class="line">       head.append(new Mylist(30));</div><div class="line">       head.append(new Mylist(40));</div><div class="line">       head.append(new Mylist(50));</div><div class="line">       head.add(new Mylist(20));</div><div class="line">       head.show();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">#### 二． 双向循环链表</div><div class="line">&gt; 注：对于一个线性结构，每一个结点都有它的前驱和后继，就是说，每个单元都有两个指针，一个指向前驱，另一个指向后继，其中第一个单元的前驱和最后一个单元的后继为空指针。</div><div class="line">双向链表：为解决效率问题，在基础结点的数据结构中增加一个域（以空间换取时间效率），它的指针指向该单元的上一单元（前驱），另外一个域的指针指向后继。任给一个元素，现在可以向前也可以向后查找，更加方便快捷。</div><div class="line">(双向)循环链表：让第一个元素的前驱指向最后一个单元，让最后一个单元的后继指向第一个单元，这样便构成了循环链表，使用循环链表的好处是头尾并不特殊，这样有利于进行统一的处理。</div><div class="line"></div><div class="line">#### 三．队列与栈</div><div class="line">1. 队列与栈都是更高一层的数据结构抽象，其底层可用链表，数组或其他手段来实现，这种方式一般称它为包装类型，在设计模式中也称为门面模式（即它的功能没什么变化，只是与用户的接口形式发生了变化）。</div><div class="line">2. 栈是在一端进行操作的线性结构，而队列是在两端进行操作的线性结构，其变种分别如双栈，优先队列等.</div><div class="line">3. Java中，队列用Queen表示，它是一个接口，而栈(Stack)则表现为一个具体的类。</div><div class="line"></div><div class="line">&gt; ＊Queen接口有许多像LinkedList这样的实现类，它就是前面所说的链表的一个变种（双向循环链表）。另外，从Java API中可以看出Stack类是从Vector类继承过来的。事实上，stack类并没有实现真正的代码，它仅仅是通过Vector类实现了所有功能，然后对用户的接口做了更改，即我们前面说的门面模式。</div><div class="line">注：Vector 是Java中常用的数据结构，被称为动态数组，它有很多种方法，而Stack方法确很少，这样就简化了它对用户的接口，使我们在使用的时候站在一个更高的抽象层上。</div><div class="line"></div><div class="line">4. 作为Java开发者，我们可使用像Vector，LinkedList等这些 具体的类，而不去使用像Stack和Queen这些更高抽象层。但从设计和程序的架构角度而言，可以通过使用这些更高层次的抽象使我们的程序更加完美，更便于维护和扩展。</div><div class="line"></div><div class="line">#### 四．二叉排序树</div><div class="line">1. 内存中，链表和数组都是线性结构，实际上对象间由指针所构成的关系可以表现的更加复杂，比如说可以有分叉关系，这种分叉关系也可以大体分为两类，一类是没有循环的可以广义的称它为树，其它的称为图。</div><div class="line">2. 树的特点：从一个结点到另一个结点只有唯一的路径；图的特点：可以有多个路径，也即是存在“圈”这种特征。</div><div class="line">3. 在数据结构书上树的标准定义中，树的所有孩子是平等无区别的，所以二叉树理论上不能算作树，在这把二叉树也归为一种广义的树形结构。</div><div class="line">4. 二叉树有很多重要的用途，比如著名的哈夫曼编码树。把二叉树用于排序的应用：即二叉树排序（最多只能分两个叉，可分别称为左子树和右子树）</div><div class="line">5. 树结构本身是递归定义的，也就是说一颗树的局部仍然是一颗树，甚至可以把一个单独的节点也称为一棵树（没有孩子的特殊的树）。每棵树都有一个很特殊的节点，即根节点，只有这个节点是没有父节点的。中间节点有的有孩子有的没有孩子，这些节点称为叶子节点。</div><div class="line">6. 把树当做对象来看待，可进行多种操作，其中十分重要的一种操作是遍历操作，</div><div class="line">7. 最常用的遍历：</div><div class="line">前序遍历（先根序遍历）：根，左，右</div><div class="line">中序遍历（中根序遍历）：左，根，右</div><div class="line">8. 组成二叉树的这个节点，它的结构应当包括三个部分：一个部分用来装数据，其它两个部分是指向左子树和右子树的指针。</div></pre></td></tr></table></figure>
<p>eg. Java代码实现二叉排序树：如12，9，5，8，15，20，把比（根）节点小的树放在左边，比其大的数放在右边。区分左右子树的比较过程中隐含的实现了数字大小排序。<br>class BiTree {/<em>定义二叉树：</em>/<br>    private int data;<br>    private BiTree left;<br>    private BiTree right;<br>    public BiTree(int x) {<br>       data = x;<br>    }<br>    public void add(BiTree x) {<br>       if (x.data &lt; this.data) { // 把x的值和目前的值进行比较<br>           if(left == null){// 如果left空閒，可以把x作為左子樹<br>              left = x;<br>           }else<br>              left.add(x);// 如果left已經被佔用了，直接把x交給left,讓它去做增加<br>       } else {<br>           if(right == null)<br>              right = x;<br>           else<br>              right.add(x);<br>           }<br>       }<br>    public void travel() {// 根據中序遍歷的規則很容易用遞歸的方式寫出<br>       if (left != null){<br>                 left.travel();}<br>       System.out.println(data);<br>       if (right != null){<br>                 right.travel();}<br>    }<br>}</p>
<p>public class Test02{/<em> 使用二叉树： </em>/<br>    public static void main(String[] args) {<br>       BiTree t = new BiTree(12);// 首先定义一个（根）节点<br>       t.add(new BiTree(9)); //通过增加节点建立二叉树,通过new BiTree(9)创建只有一个节点的树,然后把这棵树作为参数传进来<br>       t.add(new BiTree(5));<br>       t.add(new BiTree(8));<br>       t.add(new BiTree(15));<br>       t.add(new BiTree(20));<br>       t.travel();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 五．一般的树形结构</div></pre></td></tr></table></figure></p>
<p>eg. 实现一般的树形结构（有多个孩子节点）：<br>import java.util.*;<br>class MyTree{<br>    private List<node>  lst = new ArrayList<node>();//为内部类Node添加一个重要的数据成员<br>    class Node{ //内部类<br>       String data;<br>       String parent;<br>    }<br>    public void add(String parent, String child){<br>       Node t = new Node();<br>       t.data = child;<br>       t.parent = parent;<br>       lst.add(t);//把新创建的这个节点加入lst中，完成加入动作<br>    }<br>    public String getParent(String x){//查询某个节点的父节点<br>       for(int i=0; i<lst.size(); i++){="" if(lst.get(i).data.equals(x))="" return="" lst.get(i).parent;="" }="" null;="" public="" list<string=""> getChild(String x){//查询某个节点的孩子节点<br>       List<string> t = new ArrayList<string>();<br>       for(int i=0; i<lst.size(); i++){="" if(lst.get(i).parent.equals(x))="" t.add(lst.get(i).data);="" }="" return="" t;="" public="" class="" test03{="" static="" void="" main(string[]="" args)="" {="" mytree="" a="new" mytree();="" a.add("中国","北京");="" a.add("中国","河北");="" a.add("中国","江苏");="" system.out.println(a.getparent("河北"));="" system.out.println("----------");="" system.out.println(a.getchild("中国"));="" <figure=""><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 六．通用菜单</div><div class="line">菜单结构和树形结构有很大的相似性，可在一个菜单的结构中使用树形结构来表示它的逻辑。这里将实现的不是一般的简单的菜单，它的数据项将来是可以变化的，它可以支持任意的菜单ˎ子菜单的数据。</div></pre></td></tr></table></lst.size();></string></string></lst.size();></node></node></p>
<p>eg. （本例中直接把前面的MyTree拿过来使用，实现快捷添加）<br>import java.util.List;<br>import java.util.Scanner;</p>
<p>public class MyMenu {<br>    MyTree tree = new MyTree();<br>    public void add(String parent, String child) {<br>       tree.add(parent, child);<br>    }<br>    public String go(String x) {<br>       Scanner scan = new Scanner(System.in);<br>       for (;;) {<br>           List<string> lst = tree.getChild(x);<br>           if (lst.isEmpty()){<br>              return x;}<br>           System.out.println(“————–”);<br>           for (int i = 0; i &lt; lst.size(); i++) {<br>              System.out.println(i + “.” + lst.get(i));<br>           }<br>           System.out.println(“u. 返回上级菜单”);<br>           System.out.println(“————–”);<br>           System.out.print(“请输入选择：”);<br>           String s = scan.nextLine();<br>           if (s.equals(“u”)) {<br>              String x1 = tree.getParent(x);<br>              if (x1 != null){<br>                  x = x1;<br>              continue;}<br>           }<br>           try {<br>              String x1 = lst.get(Integer.parseInt(s));<br>              x = x1;<br>           } catch (Exception e) {<br>              System.out.println(“请从新选择！”);<br>           }<br>       }<br>    }</string></p>
<pre><code>public static void main(String[] args) {
   MyMenu m = new MyMenu();
   m.add(&quot;世界&quot;, &quot;亚洲&quot;);
   m.add(&quot;世界&quot;, &quot;欧洲&quot;);
   m.add(&quot;世界&quot;, &quot;美洲&quot;);
   m.add(&quot;亚洲&quot;, &quot;中国&quot;);
   m.add(&quot;亚洲&quot;, &quot;日本&quot;);
   m.add(&quot;亚洲&quot;, &quot;韩国&quot;);
   m.add(&quot;中国&quot;, &quot;北京&quot;);
   m.add(&quot;中国&quot;, &quot;河北&quot;);
   m.add(&quot;中国&quot;, &quot;江苏&quot;);
   String t = m.go(&quot;世界&quot;);
   System.out.println(&quot;您选择：&quot; + t);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 第三章   Java内置数据结构</div><div class="line">#### 一． 数组与动态数组</div><div class="line">1. Java也提供了对基本数据结构的支持，但从实用的角度出发，Java并没有提供我们前面讲的三种基本数据结构（从形态上划分为：线性结构，树形结构和图）而是代之以Se，List ，Map这三大接口。</div><div class="line">2. Java通过数组和动态数组（List家族）来进行支持线性结构。对于List而言，使用最多的实现类是Vector或者ArrayList，它们可以理解为块链结构，那就是每个单元都是数组，然后多个数组间再通过指针构成链表，这样的结构使它在访问效率上比较折中。</div><div class="line">3. List, Set,Map三者的用法以及区别：</div><div class="line">1）List和Set都是单列集合，他们有一个共同的父接口---Collection。</div><div class="line">List是依次列出一个集合中的所有的元素，允许重复，且有序；</div><div class="line">Set列出的集合元素中不允许有重复，Set中的对象不按特定方式排序（默认正向排序），</div><div class="line">但它的有些实现类能对集合中的对象按特定方式排序，例如TreeSet类，TreeSet支持两种排序方式，自然排序和定制排序，其中自然排序为默认的排序方式。</div><div class="line">￭自然排序：实现Comparable接口，重写接口中的int compareTo(Object obj)方法来比较元素之间的大小关系，然后将元素按照升序排列，该方法返回整型(-1/0/1, 小于/等于/大于)。</div><div class="line">￭定制排序：实现Comparator接口，重写接口中的int compare(Object obj1，Object obj2)方法，该方法返回整型。</div><div class="line">￭一般遍历set里面的元素时使用Iterator。</div><div class="line">2）map&lt;key,value&gt; 是一个双列集合。里面有一个key和一个value，其中value是真正存储值的变量。map存储的数据是无序的，其键（key）+不能重复，但是其值（value）是可以重复的。</div></pre></td></tr></table></figure></p>
<p>eg. 实例：java代码去掉重复语句</p>
<p>import java.util.*;<br>public class My1{<br>    public static void main(String[] args) {<br>       List<string> lst = new ArrayList<string>();<br>       lst.add(“abc”);<br>       lst.add(“xyz”);<br>       lst.add(“ttt”);<br>       lst.add(“abc”);<br>       lst.add(“dog”);<br>       lst.add(“dog”);<br>       lst.add(“dog”);<br>       lst.add(“cat”);</string></string></p>
<pre><code>   for(int i=0; i&lt;lst.size(); i++){
       int j = lst.lastIndexOf(lst.get(i));
       if(i != j) {
          lst.remove(j);
          i--; //元素循环一圈后原地不动而进行同样的动作直到没有可删除的为止
       }
   }
   System.out.println(lst);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 二． Set接口与应用</div><div class="line">1. HashSet 是以一种散列表的形式来实现Set接口。</div><div class="line">2. 集合的交叉并补</div></pre></td></tr></table></figure></p>
<p>Set在Java中实际应用的例子（Java中差集的演示）：<br>eg.<br>import java.util.*;<br>public class SetTest<br>{<br>    public static void main(String[] args)<br>    {<br>       String[] a = {“zhang”,”wang”,”li”,”wu”,”han”};<br>       String[] b = {“zhang,数学,88”, “zhang,语文,89”,”zhang,英语,78”,”wu,数学,99”,”wu,英语,66”,”tang,数学,77”};</p>
<pre><code>    //求哪些同学所有科目都缺考
   Set&lt;String&gt; sa = new HashSet&lt;String&gt;();
   for(int i=0; i&lt;a.length; i++) sa.add(a[i]);
   Set&lt;String&gt; sb = new HashSet&lt;String&gt;();
   for(int i=0; i&lt;b.length; i++) sb.add(b[i].split(&quot;,&quot;)[0]);

   sa.removeAll(sb);//求差集（sa-sb）

   //集合里面的元素是没有顺序的，不能像动态数组一样去求size,然后get某一项。
   //如何取得集合中的每一个元素（即遍历集合），Java提供了一种标准手段，叫枚举或者叫迭代
   //任何实现Collection接口的这些类都会提供一个Iterator，它会返回一个Iterator接口
   Iterator&lt;String&gt; it = sa.iterator();
   while(it.hasNext()){
       System.out.println(it.next());
   }
   //System.out.println(sa);
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&gt;&gt; 补充：★在java集合中顶层有这样两个接口Iterator和Enumeration，这两个接口是特殊的数据操作接口。Iterator用于进行数据迭代，称为迭代器；Enumeration用于进行数据枚举，称为枚举。</div><div class="line">&gt;&gt; + 枚举：</div><div class="line">该接口定义了可以对一个对象类集合中的元素进行枚举的方法，但目前已被迭代器所替代。</div><div class="line">在枚举中定义了如下两个方法：</div><div class="line">boolean hasMoreElements():判断集合中是否有元素可提取，有该方法就返回true，否则返回false</div><div class="line">Object nextElement() :将枚举中的下一个对象作为一个类属Object的引用而返回。也就是每次调用nextElement()方法获得枚举中的下一个对象。</div><div class="line">&gt;&gt; + 迭代：</div><div class="line">迭代器&lt;Iterator&gt;和枚举&lt;Enumeration&gt;的功能差不多，但在集合中推荐使用迭代器进行跌代。</div><div class="line">迭代器定义了如下三个方法：</div><div class="line">boolean hasNext():判断集合中是否有元素可迭代；</div><div class="line">E next()：返回迭代的下一个元素；</div><div class="line">Void remove():移除迭代器返回的最后一个元素。</div><div class="line"></div><div class="line">#### 三． 散列的原理</div><div class="line">1. 散列是Hash（音译为哈希）这个外来词汇的意译。散列在现代的存储理论和数据库等领域都是十分关键的。散列的目标是已知一个关键字（在全局内是唯一的）能迅速地找到要查找的对象所在的位置。散列的基本思想是想通过某个数学公式进行计算，把关键字映射到对象存储位置信息（其空间大小往往小于关键字的可能空间）。</div><div class="line"> </div><div class="line">2. 散列特征：</div><div class="line">无视数据规模，能快速定位；</div><div class="line">会占用更大的空间；</div><div class="line">是典型的以空间换取时间；</div><div class="line">3. 散列冲突：两个不同关键字经过相同的数学变换，有时可能会碰巧得到同样的一个地址信息。它可通过各种策略来解决，其中最常用的策略就是顺序地向下去寻找。可以这样说，对象就存储在它的散列值所表达的位置的附近。</div><div class="line"></div><div class="line">#### 四． HashSet重复标准</div><div class="line">1. Set接口中并没有描述什么叫重复，什么是重复的标准，各个不同的具体实现类都会有自己的处理方法。</div><div class="line">2. HashSet是使用最多的Set类型 它判断重复的标准如下：</div><div class="line">1）HashSet先去检查了新加入对象的hashCode是否与已有的对象的hashCode发生了碰撞，如果没有碰撞，这说明必然不会重复，它就不再去调用equals方法进行比较了，否则调用equals方法，返回true才表明两个对象在内容上是真正的相同，这时候对象就被阻止在集合外面不被加进来了。（因此HashSet判断一个元素是否与集合中已有元素重复时的效率是相当高的，因为即使有很多元素，真正发生碰撞的元素毕竟是少数，如此调用equals方法的次数就很少。）</div><div class="line">2）HashSet没有办法帮助我们自定义的类型去决定什么是逻辑上的重复，因为它不知道我们是按照何种应用逻辑来决定是否重复。</div></pre></td></tr></table></figure></p>
<p>eg.  import java.util.*;<br>class Person { // 自己定义Person类<br>    private String name;<br>    private int age;<br>    public Person(String name, int age) {<br>       this.name = name;<br>       this.age = age;<br>    }<br>    public boolean equals(Object x) { //重写equals()<br>       if (x instanceof Person == false){return false;}else<br>       {Person p = (Person) x;}<br>       return this.name.equals(p.name) &amp;&amp; this.age == p.age;//只有名字和年龄都重复才叫重复<br>       // return true;<br>    }<br>    public int hashCode() {//散列码决定对象存储位置 重写hashCode()<br>       return this.name.hashCode() + this.age;<br>       // return 100;<br>    }<br>    public String toString() {//重写toString()<br>       return name + “: “ + age;<br>    }<br>}</p>
<p>public class HashSetTest {<br>    public static void main(String[] args) {<br>       Set<person> a = new HashSet<person>();<br>       a.add(new Person(“zhang”, 10));<br>       a.add(new Person(“zhang”, 11));<br>       a.add(new Person(“zhang”, 10));<br>       a.add(new Person(“li”, 10));<br>       System.out.println(a); //HashSet默认情况下认为我们这些对象都是逻辑上不重复的<br>       /*</person></person></p>
<pre><code>    * Set&lt;String&gt; a = new HashSet&lt;String&gt;();
    * a.add(&quot;abc&quot;);
    * a.add(&quot;xyz&quot;);
    * a.add(&quot;abc&quot;);//为了验证，也可改成a.add(new String(&quot;abc&quot;));
    * System.out.println(a); //结果没有输出两个adc，可见HashSet去判断对象是否重复，它用的是逻辑方式，并不是比较两个对象的地址。
    */
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 五．TreeSet与排序</div><div class="line">1. 根据HashCode判断重复的标准，试着去覆盖hashCode()和equals()方法，发现它们根本不起作用，这是因为TreeSet并不是用散列来进行内部对象的存储位置安排的。从名字上可感觉到它是使用了树形结构，更准确的说它是一种排序树，也就是说TreeSet要求加进来的所有元素必须都可以比较大小。而实际上并非所有元素都能够（或有必要）比较大小。</div><div class="line">2. Java支持两种标准方式：</div><div class="line">对象本身就支持一个叫Comparable的接口，任何支持了该接口的对象都实现了compareTo() 方法。（即Comparable类型的对象都有能力自己解决比较问题）</div><div class="line">对象并不需要承担比较大小的责任，而是聘请一个外来的，外部的裁判对象，来负责判定两个对象的大小关系。这种方式的优点是可以聘请不同的裁判来获得不同的比较结果。</div><div class="line">3. TreeSet如何来处理冲突问题</div></pre></td></tr></table></figure></p>
<p>eg. 实例：<br>import java.util.<em>;<br>/</em><br> //对象自身实现了Comparable接口来实现比较<br> class Person implements Comparable {<br> private String name;<br> private int age;</p>
<p> public Person(String name, int age) {<br> this.name = name;<br> this.age = age;<br> }<br> public String toString() {<br> return name + “: “ + age;<br> }<br> public int compareTo(Object x) {// 重写compareTo()方法<br> if (x instanceof Person == false) {<br> return 0;<br> } else {<br> Person p = (Person) x;<br> // return this.name.compareTo(p.name);<br> int t = this.name.compareTo(p.name);<br> if (t != 0) {<br> return t;<br> } else {<br> // return this.age - p.age;<br> return p.age - this.age;<br> }<br> }<br> }<br> */<br>// 非侵入方式：不需要对象增加一些接口或方法就让其具有比较的能力<br>class Person {<br>    private String name;<br>    private int age;<br>    public Person(String name, int age) {<br>       this.name = name;<br>       this.age = age;<br>    }<br>    public String getName() {<br>       return name;<br>    }<br>    public int getAge() {<br>       return age;<br>    }<br>    public String toString() {<br>       return name + “: “ + age;<br>    }<br>}</p>
<p>class K implements Comparator {// 新定义一个类型K（可称为裁判类(术语叫比较器)）<br>    public int compare(Object a, Object b) {// 重写compare()方法<br>       if (a instanceof Person == false || b instanceof Person == false) {<br>           return 0;<br>       } else {<br>           Person p1 = (Person) a;<br>           Person p2 = (Person) b;<br>           int t = p1.getName().compareTo(p2.getName());<br>           if (t != 0) {<br>              return t;<br>           } else {<br>              return p1.getAge() - p2.getAge();<br>//可写成return p1.getAge()-p2.getAge();按字母排序，字母相同则按年龄降序排列<br>           }<br>       }<br>    }<br>}<br>    public class TreeSetTest{<br>       public static void main(String[] args){<br>           //Set<person> a = new TreeSet<person>();<br>           Set<person> a = new TreeSet<person>(new K());<br>           a.add(new Person(“hao”, 10));<br>           a.add(new Person(“hao”, 20));<br>           a.add(new Person(“hao”, 30));<br>           a.add(new Person(“hao”, 10));<br>           a.add(new Person(“zhang”, 10));<br>           a.add(new Person(“zhang”, 11));<br>           a.add(new Person(“zhang”, 20));<br>           a.add(new Person(“li”, 40));<br>           System.out.println(a);<br>       }<br>    }</person></person></person></person></p>
<blockquote>
<p>￭注：Java中涉及到判断大小的地方很可能用的就是上述两种判断标准，如Arrays.sort(数组)，<br>Collection.sort(动态数组/list)，同样存在自定义元素比较大小问题，仍然可采用上述方案。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 六．对象比较</div><div class="line">1. 对象的比较关系：</div><div class="line">+ 是否相等：</div><div class="line">比较指针是否指向同一个对象（==）;比较两个对象在逻辑上是否是等价的（equals()）;</div><div class="line">注：</div><div class="line">Object方法中的equals()仅仅是一个空壳，想要实现对内容的比较，需要覆盖equals()。</div><div class="line">虽然我们可以自定义比较规则，但是一般情况下要满足a.equals(a)必须返回true，即一个对象必须要和它自己逻辑等价(自反性，对称性，传递性)。</div><div class="line">在定义自己类的equals()方法时最好也能去覆盖hashCode()方法，对于equals返回是true的情况必须保证hashCode返回的值也相同。</div><div class="line">④比较相同并不能决定两个对象谁大谁小，即无法进行排序。要想实现排序必须比较出对象间更多的信息来，而不仅仅是像equals那样只返回布尔值。</div><div class="line"> </div><div class="line">+ 大小比较(a.compareTo(b)/compare(a,b))</div><div class="line">比较大小一定要返回三种信息：大于，等于，小于(Java中一般是返回一个整数（正数，0，负数）)，显然比较大小就隐含的比较了是否相等。</div><div class="line">a.compareTo(b)如果返回0，a.equals(b)就一定要返回true，这两者是相关联的。</div><div class="line"></div><div class="line">#### 七．Map接口与特性</div><div class="line">1. 类似数学中的函数概念（每一个x都有唯一的y与它对应，称y是x的函数），同样的，计算机中的函数被看成键值对，键是唯一的而值可以重复，这样从一个确定的键就可以确定出唯一的值。 Map可以看成是键值对的集合，从一个键出发可以快速的找到相应的值。</div><div class="line">2. 键和值都可以是任何一种对象，但具体的实现类却有具体的要求。</div><div class="line">3. Map的特性是一个键可以对应一个值，多个键也可以对应同一个值，但一个键绝不能对应于多个不同的值。正因为这个特性键才是不重复的。</div><div class="line">4. 把重复的键和值这种对应关系加入Map中时，后面加入的键会覆盖前面加入的键对。</div><div class="line">5. 把Map中的键值全部输出：</div><div class="line">1）调用keySet()方法取得键集（把Map转化成集合）,然后可调用iterrator()方法遍历该集合。</div><div class="line">2）调用entrySet()方法直接取出键值对。（返回的是一个内部接口类型Map.Entry&lt;string,string&gt;,也可不用泛型</div></pre></td></tr></table></figure></p>
</blockquote>
<p>eg. import java.util.*;<br>public class MyA {<br>    public static void main(String[] args) {<br>       Map<string, string="">  a = new  HashMap<string, string="">();<br>       a.put(“cat”, “猫”);<br>       a.put(“desk”, “桌子”);<br>       a.put(“table”, “桌子”);<br>       a.put(“table” ,”表格”);</string,></string,></p>
<pre><code>   System.out.println(a.get(&quot;table&quot;));

   // 遍历表格
   Set&lt;String&gt; key = a.keySet();
   Iterator&lt;String&gt; it = key.iterator();
   while(it.hasNext()){
       String s = it.next();
       System.out.println( s + &quot;----&gt;&quot; + a.get(s));
   }

   Set&lt;Map.Entry&lt;String, String&gt;&gt;  et = a.entrySet();
   Iterator&lt;Map.Entry&lt;String, String&gt;&gt; it2 = et.iterator();
   while(it2.hasNext()){
       System.out.println(it2.next());
   }
}
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 八． Map典型应用</div></pre></td></tr></table></figure></p>
<p>eg. 快速找到父节点<br>import java.util.*;<br>class MyTree{<br>    private  Map map_up = new HashMap();//子–&gt;父<br>    private Map map_down = new HashMap();//父–&gt;子（所有孩子）<br>    public void add(String parent, String child){<br>       map_up.put(child, parent);//把child作为键，parent作为值，就能表达由子到父这种联系。<br>       List lst = (List)map_down.get(parent);//把所有孩子装进一个list,再由parent指向该list,即变相表示一对一关系<br>       if(lst == null){<br>           lst = new ArrayList();<br>           map_down.put(parent, lst); //创建了键值对<br>       }<br>       lst.add(child);<br>    }<br>    public String getParent(String x)<br>    {<br>       return (String)map_up.get(x);<br>    }<br>    public List getChild(String x)<br>    {<br>       return (List)map_down.get(x);<br>    }<br>}<br>public class MyA {<br>    public static void main(String[] args){<br>       MyTree a = new MyTree();<br>       a.add(“世界”,”亚洲”);<br>       a.add(“世界”,”欧洲”);<br>       a.add(“世界”,”美洲”);<br>       a.add(“亚洲”,”中国”);<br>       a.add(“亚洲”,”韩国”);<br>       a.add(“亚洲”,”日本”);<br>       a.add(“中国”,”北京”);<br>       a.add(“中国”,”江苏”);<br>       a.add(“中国”,”山东”);<br>       a.add(“中国”,”河北”);<br>       System.out.println(a.getParent(“河北”));<br>        System.out.println(a.getChild(“中国”));<br>    }<br>}</p>
<blockquote>
<p>注：以上实例使用了Java提供的内置数据结构-Map，代码相当简洁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 第四章   排序应用</div><div class="line">#### 一．树形选择排序</div><div class="line">1. 是模拟竞标赛规则发明的。它要求待排元素的数目为2^n个，如果元素数目不够，可补充一些无用的元素来占位（比如用无穷大）。尚未排序的元素要作为叶子节点，由它们开始向上逐步的去建立二叉树。</div><div class="line">2. 要点：两两比较，输出当前的最小元素（优胜者）后，要把该元素所在叶子节点填写为无穷大，然后再把所有变动过的组重新进行比拼。</div><div class="line"></div><div class="line">#### 二．归并排序</div><div class="line">1. （merge）归并排列就是把两个已经排序好的队列合成一个有序队列。</div><div class="line">2. 建立两个指针分别指向两个已经排序了的队列的首地址，新比较两个地址的值，把小的值放入新建的队列，并移动指针继续比较。</div><div class="line"></div><div class="line">#### 三．堆排序</div><div class="line">1. 树形选择排序浪费内存，因此提出堆排序的概念。如果一颗完全二叉树的每个节点都不大于它的子节点就可以称之为堆。</div><div class="line">注：</div><div class="line">完全二叉树：除了叶子节点外所有其它节点都有完整的左子树和右子树。除最后一层外，每一层上的结点数均达到最大值；在最后一层上只缺少右边的若干结点，对于完全二叉树来说，叶子结点只可能在层次最大的两层上出现。</div><div class="line">满二叉树：除最后一层外，每一层上的所有结点都有两个子结点。在满二叉树中，每一层上的结点数都达到最大值。</div><div class="line">满二叉树肯定是完全二叉树，完全二叉树不一定是满二叉树。</div><div class="line">2. 脉络：</div><div class="line">1）先把无序待排数字填充成完全二叉树（从上到下，从左到右）；</div><div class="line">2）建堆：可从最后一个非叶子节点开始往前看；如果节点数字比其两个孩子都大，那应该和小的数字交换，不然交换后仍不满足要求；若调整后破坏原来已经满足要求的子树则继续调整。</div><div class="line">3）从初始的堆中输出堆顶的元素，根节点就空了，可把最后一个元素提拔上来让其做根元素，之后调整这个根节点。在堆排序中把这种较大元素从顶层落到底层的过程称为“筛选”。</div><div class="line">4）以同样规则重复步骤3。堆越来越小，直到整个堆只剩下一个元素，把它也输出，堆排序过程就结束了。</div><div class="line">5）原理上看堆排序可用二叉树的结构来表示，但在实际运用中可用一维数组表示这个二叉树。当然，对于一般的二叉树是不能这样表示的。现在的完全二叉树具有特殊性，我们可用数组来简单的表示它。（一维数组占内存小，完全二叉树耗内存大）</div><div class="line"></div><div class="line">#### 四．多关键字排序</div><div class="line">1. 一个对象可以用多个特征值来刻画它，可把每个特征值看成是一个关键字。如果所要求的顺序是由多个关键字联合决定，我们就可以利用这种特征来使用多关键字排序的方法。多个关键字的地位不是平等的，有一个优先级的大小。</div><div class="line">2. 模拟扑克牌排序（花色，点数...）：</div><div class="line">1）MSD: 高关键字优先</div><div class="line">2）LSD: 低关键字优先（不断分组收集）</div><div class="line">注：关键字的空间不能太大，否则分组太多，效率会很低。这种排序算法适合那种关键字很多但是每个关键字的空间又不是很大的场合。（有时如果关键字的空间太大，可以把一个关键字拆成多个小的关键字。）</div><div class="line"></div><div class="line">#### 五．链式基数排序</div><div class="line">1. 把待排序的元素用链表来存储，在分组时仅仅移动指针而不学要分配额外的空间。当然也许浪费一定空间，对每一个关键字需要分配头尾指针。</div><div class="line">2. Java中可使用现成的类来代替头尾指针，使排序的代码比较简单。</div></pre></td></tr></table></figure></p>
</blockquote>
<p>eg. 使用如LinkedList作为分组和收集里面的那个小组，它本身就具有头尾指针，无需额外定义：<br>import java.util.<em>;<br>public class MyA{<br>    public static void main(String[] args){<br>       List data = new ArrayList();<br>       //填充随机值<br>       for(int i=0; i&lt;1000; i++)<br>           data.add((int)(Math.random() </em> 10000));<br>       //准备十个桶<br>       List[] base = new ArrayList[10];<br>       for(int i=0; i<base.length; i++)="" base[i]="new" arraylist();="" 从低到高，分配与收集="" for(int="" k="1;" k<="1000;" k*="10){" i="0;" i<data.size();="" base[(integer)data.get(i)="" k%10].add(data.get(i));="" 按关键字分配到桶里="" data.clear();="" i<base.length;="" data.addall(base[i]);="" 收集,(用addall()而不用add()可把分组加进来)="" base[i].clear();="" 清桶="" }="" system.out.println(data);="" <figure="" class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">### 第五章 图的应用</div><div class="line">#### 一. 图的表示</div><div class="line">1. 图是网状结构，它是数构中最复杂的元素，可以有多种表达方式，如邻接矩阵或邻接表，两种表达方式不能直观回答a是否和b连通，a到b最短路径这些问题，需由相关图的算法实现（如最短路径，最大流问题，关键路径问题，二部图问题等，这些都有了经典算法）。</div><div class="line"></div><div class="line">#### 二. 深度优先遍历</div><div class="line">1. 有些类似树的先根序遍历，不同的是，树形结构从一个节点到另一个节点只有一条路径，不会出现重复遍历的情况，而图则需对已经遍历过的节点进行标注，防止下次重复遍历。</div><div class="line">2. 深度遍历是先输出某个孩子的整个家族体系，然后才是下一个孩子的家族体系。</div></pre></td></tr></table></base.length;></p>
<p>eg1.<br>public class MyA {<br>    // 借助递归，简化代码<br>    public static void deepTravel(int[][] a, int[] color, int k) {<br>       System.out.println(k);// 通过打印它来表示遍历了K号节点<br>       color[k] = 1;// 做标记，表示该节点已经被遍历过了<br>       for (int i = 0; i &lt; a[k].length; i++) {// 遍历a的第k行的所有元素，每个元素即表示k所连接的那些顶点<br>           if (a[k][i] == 1 &amp;&amp; color[i] == 0) {// a[k][i]==1，表示二者之间存在连接，color[i]==0表示这个孩子未被标记<br>              deepTravel(a, color, i);// 递归调用<br>           }<br>       }<br>    }<br>    public static void main(String[] args) {<br>       // 需重开一个数组，记录标记信息<br>       int[][] a = {<br>// 用邻接矩阵来表示图【无向图（相互连通）矩阵是关于主对角线对称的】<br>         { 0, 1, 1, 1, 0 },<br>         { 1, 0, 1, 1, 1 },<br>         { 1, 1, 0, 0, 0 },<br>         { 1, 1, 0, 0, 0 },<br>         { 0, 1, 0, 0, 0 }<br>};<br>       int[] color = new int[a.length];<br>       deepTravel(a, color, 0);// 传入的参数分别是图，标记的数组以及开始遍历的节点<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#### 三． 广度优先遍历</div><div class="line">1. 适合于类似于求最短路径这样的场合，从形式上看有些类似于对树形结构进行逐层的遍历。对于图，同样需对已经遍历过的节点进行标记。</div><div class="line">2. 不同于深度遍历，先输出一个根节点的所有直接孩子，同时对已经输出的节点进行标记，防止下次再输出它，第一层输出完毕后再回来处理第二层节点，如此下去直到它们都已经被输出为止，遍历结束。</div></pre></td></tr></table></figure></p>
<p>eg1.<br>import java.util.*;<br>public class MyA {<br>    public static void main(String[] args) {<br>       // 图的邻接表定义<br>       int[][] g = {<br>              { 0, 1, 1, 0, 0, 0, 0 },<br>              { 1, 0, 0, 1, 0, 0, 1 },<br>              { 1, 0, 0, 0, 0, 1, 1 },<br>              { 0, 1, 0, 0, 1, 0, 0 },<br>              { 0, 0, 0, 1, 0, 1, 1 },<br>              { 0, 0, 1, 0, 1, 0, 0 },<br>              { 0, 1, 1, 0, 1, 0, 0 }<br>           };<br>       List lst = new ArrayList();// 等待遍历的节点<br>       Set set = new HashSet(); // 已经遍历节点的集合<br>       lst.add(0);// 加入一个初始节点</p>
<pre><code>   while (true) {
       if (lst.isEmpty()) {
          break;
       } else {
          int node = (Integer) lst.get(0);
          System.out.println(node);
          set.add(node);
          lst.remove(0);
          for (int i = 0; i &lt; g[node].length; i++) {
              //使用邻接表，next_layer.indexOf(j)&lt;0)判断i节点是否已经遍历
              if (g[node][i] == 1 &amp;&amp; set.contains(i) == false &amp;&amp; lst.indexOf(i)&lt;0){
                 lst.add(i);
              }
          }
       }
   }
}
</code></pre><p>}</p>
<pre><code>
</code></pre><p>eg2.(调用递归简化代码)<br>public class MyA{<br>    // cur_layer: 当前层<br>    static void widthTravel(int[][] g, Set tag, List cur_layer){<br>       // 遍历当前层<br>       for(int i=0; i&lt;cur_layer.size(); i++){<br>           System.out.println(cur_layer.get(i));<br>           tag.add(cur_layer.get(i));<br>       }<br>       //产生下一层<br>       List next_layer = new ArrayList();<br>       for(int i=0; i&lt;cur_layer.size(); i++){<br>           int node = (Integer)cur_layer.get(i);<br>           for(int j=0; j&lt;g[node].length; j++){<br>//使用邻接表，next_layer.indexOf(j)&lt;0)判断i节点是否已经遍历<br>              if(g[node][j]==1 &amp;&amp; next_layer.indexOf(j)&lt;0)                                                           next_layer.add(j);<br>             }<br>       }<br>       next_layer.removeAll(tag);<br>       if(next_layer.isEmpty()==false)<br>            widthTravel(g, tag, next_layer);<br>    }<br>    public static void main(String[] args){<br>       // 图的邻接表定义<br>       int[][] g = {<br>           {0,1,1,0,0,0,0},<br>           {1,0,0,1,0,0,1},<br>           {1,0,0,0,0,1,1},<br>           {0,1,0,0,1,0,0},<br>           {0,0,0,1,0,1,1},<br>           {0,0,1,0,1,0,0},<br>           {0,1,1,0,1,0,0}<br>       };<br>       Set tag = new HashSet();  //保存已经遍历的节点<br>       List layer = new ArrayList();//待遍历的节点<br>       layer.add(0);//加入一个初始节点<br>       widthTravel(g, tag, layer);<br>    }<br>}<br>``` </p>
<h4 id="四．最短路径"><a href="#四．最短路径" class="headerlink" title="四．最短路径"></a>四．最短路径</h4><h3 id="第六章-综合应用"><a href="#第六章-综合应用" class="headerlink" title="第六章 综合应用"></a>第六章 综合应用</h3>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/04/20/C语言要点笔记/" itemprop="url">
                  C语言要点笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-04-20T00:00:00+08:00" content="2016-04-20">
              2016-04-20
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/编程基础/" itemprop="url" rel="index">
                    <span itemprop="name">编程基础</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一．基础"><a href="#一．基础" class="headerlink" title="一．基础"></a>一．基础</h3><ol>
<li>位运算补码（取反加一）是为了计算负数。</li>
<li>编译原理：<br>源文件——.i文件——.s文件（汇编文件）——.o文件（二进制文件）——可执行文件（预处理——汇编——编译——执行）</li>
<li>Gcc（C语言编译器）+vim（linux自带的字符编辑器）<br>【eg.  vim 文件名，gcc 文件名，./a.out（输出）】</li>
<li>C语言基础语法：<br>1）if嵌套最多15层，If语句一般三到四层，else if最多写7个，switch（里面的表达式只能是char和Int类型）。<br>2）循环语句的老祖宗Goto语句【语法：（声明变量，定义标签（：），if判断，goto 标签）】</li>
</ol>
<h3 id="二．-函数"><a href="#二．-函数" class="headerlink" title="二． 函数"></a>二． 函数</h3><ol>
<li>函数调用过程原理</li>
</ol>
<blockquote>
<p>应用程序启动后(剩余)内存分配如下：</p>
<ul>
<li>环境变量区：path，language… </li>
<li>栈区：执行代码段；弹栈压栈（先进后出）；无论32位还是64位系统，栈的大小是固定的（2M），则如果声明一个结构体大小超过2M，则会造成内存溢出；  </li>
<li>Static（静态区）：</li>
<li>常量区：</li>
<li>代码段区：函数体…</li>
</ul>
<ol>
<li>★（static）静态变量 全局变量</li>
</ol>
<ul>
<li>Static修饰的变量为静态变量，采用静态存储形式，但反过来，静态存储形式的不一定就是局部静态变量，例如全局变量也是静态存储形式。</li>
<li>静态变量分为全局静态变量和局部静态变量</li>
</ul>
<p>全局静态变量与全局变量有区别：<br>虽然同为静态存储方式，但是全局静态变量失去了全局的“普遍含义”它所指的“全局”仅限制在本文件里，而全局变量却是各个文件可见的。</p>
<p>局部静态变量与局部变量有区别：</p>
<ul>
<li>A.存储方式不同，前者为静态存储方式，后者为动态存储方式；</li>
<li>B.作用域是一致的，只局限于“模块”或者“代码段”；<br>©局部静态变量最大的特点就是作用类似于全局变量，而作用域类似于局部变量，（生命周期）与应用程序同生共死，在走出了某个函数或者代码段后生命周期延续，当再次回到这个函数或者代码段时，上次走出时的值仍然保存到现在，所以一般用它来做计数器。</li>
</ul>
</blockquote>
<p>3.自动变量（auto）和寄存器变量（register），外部变量（extern）</p>
<blockquote>
<p>★变量类型用来说明变量所占空间的大小，变量存储类型用来说明变量的作用范围。<br>C语言变量存储类型有：</p>
<ul>
<li>自动类型：不加则默认（局部变量）</li>
<li>寄存器类型：放在一个CPU寄存器中（数据在寄存器中操作比在内存中快），提高了程序代码执行速度。注意：取地址符&amp;不能用于寄存器变量，它只能用于整型和字符型。</li>
<li>静态类型和外部类型</li>
</ul>
</blockquote>
<p>4.const修饰符【修饰只读变量（声明了const的变量是不能修改的）】</p>
<blockquote>
<p>C语言中的Const放在不同位置有不同的作用，在不同情况下有不同用法。在此之前，开发者一直使用宏定义：#define VAR 100 来定义一下有特殊用途的类常量，不过因其存在一些劣势，const应运而生，后来便使用const int VAR=100 来定义类常量了。两种写法存储区域不同，前者放在常量区，后者放在栈区。</p>
<blockquote>
<p>★★总结：</p>
<ul>
<li>const声明的变量必须要进行初始化赋值，如果错过这个机会，以后就不能再给const的变量赋值了。</li>
<li>int const和const int “颠倒写”都是可以的，但当const和指针掺和到一起时，“颠倒写”的规律可未必成立。</li>
<li>const和指针搭配是噩梦</li>
</ul>
</blockquote>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">eg1. </div><div class="line">int main()&#123;</div><div class="line">int a = 5;</div><div class="line">int b = 6;</div><div class="line">//int const *p=&amp;a;//const在*前面，修饰指向的对象，p可变，p指向的变量的值不可变</div><div class="line">int * const p=&amp;a;//const在*后面，修饰指针，p不可变(只读)，p指向的变量的值可变</div><div class="line">//const int *const p=&amp;a;//指针p和p指向的对象都不可变</div><div class="line">//p = &amp;b;</div><div class="line">*p = 100;</div><div class="line">return 0; </div><div class="line">&#125;</div><div class="line">结论：通俗的说，A指针可以随便指向一个整型，但只要被A盯上了的整型变量在使用*A引用时就不能修改了。</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">eg2.</div><div class="line">int num=12;</div><div class="line">int tmp=100;</div><div class="line">const int *A=#</div><div class="line">A=&amp;tmp;</div><div class="line">tmp=3</div><div class="line">printf(“result=%d\n”,*A);//输出结果为3</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">eg3.char *find_char(char const * source)&#123;</div><div class="line">char *p=(char*)source;//强制转换</div><div class="line">return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>结论：即使A指向了tmp，虽然不能修改<em>A，但是仍然可以用tmp来修改这个值，不管 </em>A</p>
</blockquote>
<p>5.volatile 修饰符<br>volatile影响编译器编译的结果变量是随时肯发生变化的，与volatile变量有关的运算，不要进行编译优化，以免出错。<br>valatile可以保证对特殊地址的稳定反应，不会出错。<br>6.可变参数列表<br><code>eg. void fun(int a,...) //不知道a后面有多少个参数，写三个点。</code><br>7.递归函数（解决复杂问题）<br>8.程序结构（以函数为最小单位）<br>9.系统函数</p>
<ul>
<li>随机数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">rand()%100：%100表范围0-100，另外，可以srand((unsigned)time(NULL))为参照物。</div><div class="line">Math.h</div><div class="line">Sqrt()：在gcc编译的时候要加-lm参数，把math库文件加进来。</div></pre></td></tr></table></figure>
<h3 id="三．-数组"><a href="#三．-数组" class="headerlink" title="三． 数组"></a>三． 数组</h3><ul>
<li>字符数组：char[5]={‘h’, ‘e’ , ‘l’ , ‘l’ , ‘o’};结尾没有”\0”。</li>
<li>字符串数组：char[10]=”hello”;虽然使用双引号初始化，但是编译器会给数组的结尾加上”\0”(转义字符)，表示结束。</li>
</ul>
<h3 id="四．-指针"><a href="#四．-指针" class="headerlink" title="四． 指针"></a>四． 指针</h3><ol>
<li><p>指针是保存内存地址的变量；可以用来存放任何已被定义的变量地址，即使他们没有被赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">eg.</div><div class="line">int num=5;//定义Int类型的变量</div><div class="line">int *p;(int*)p //声明一个Int类型的指针用来保存Int类型变量的地址</div><div class="line">p=# //取num变量的地址放到p里面</div><div class="line">printf(“%d\n,*p”); </div><div class="line">指针变量 p</div><div class="line">变量指针 *p //此处（声明后）加*（间接运算符）表示取指针里面的值，即用指针来访问值。</div></pre></td></tr></table></figure>
</li>
<li><p>空指针可以指向任何地址并对该地址的数值进行修改或者删除，所以需将其初始化为0。</p>
</li>
<li><p>不同类型变量所占内存大小不同，指针只能保存与它类型相同的变量的内存地址。<br><code>【32位系统中所有类型的指针大小都是是4个字节（正好保存4G内存地址），64位系统中是8个字节】，(sizeof(指针))</code></p>
</li>
<li><p>易混淆概念：指针地址，指针保存的地址和改地址的值。</p>
</li>
<li>为什么使用指针（堆和栈的概念）<br>虽然通过变量名可以访问数据，但在操作大型数据和类时，由于指针可以通过内存地址直接访问数据，从而避免在程序中复制大量的代码，因此指针的效率最高，一般来说，指针会有三大用途：<br>1）处理堆中堆放的大型数据。<br>2）快速访问类的成员数据和函数。<br>3）以别名的方式向函数传递参数</li>
</ol>
<blockquote>
<p>★堆和栈<br>一般来说，程序就是与数据打交道，程序执行某一功能时将给功能所需数据加载到内存中，然后在执行完毕时释放掉该内存。</p>
<ul>
<li>数据在内存中的存放形式：<br>1）栈区（stack）:由操作系统自己分配并释放，一般存放函数和参数值，局部变量等。<br>其操作方式类似于数据结构中的栈。<br>2）堆区(heap): 由程序员分配并显示释放（一般用molloc,realloc,new等函数从堆中分配到一块内存），若程序员不释放程序结束时可能由操作系统回收。<br>注意：它与数据结构中的堆是两回事，分配方式倒是类似于链表。<br>3）寄存器区：用来保存栈顶指针和指令指针（用于控制程序中指令的执行顺序）<br>4）全局区（静态区 static）：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和静态变量在相邻的另一块区域，程序结束后由系统释放。<br>5）文字常量区：存放常量字符串，程序结束后由系统释放。<br>6）程序代码区：存放函数体的二进制代码。</li>
</ul>
<p>附注：★C语言的标准内存分配函数：malloc，calloc，realloc，free等。</p>
<ul>
<li>malloc与calloc的区别为1块与n块的区别：<blockquote>
<ul>
<li>malloc调用形式为(类型*)malloc(size)：在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址。</li>
<li>calloc调用形式为(类型*)calloc(n，size)：在内存的动态存储区中分配n块长度为“size”字节的连续区域，返回首地址。</li>
<li>realloc调用形式为(类型<em>)realloc(</em>ptr，size)：将ptr内存大小增大到size。</li>
<li>free的调用形式为free(void*ptr)：释放ptr所指向的一块内存空间。<br>C++中为new/delete函数。 </li>
</ul>
</blockquote>
</li>
</ul>
<p>★★堆和栈的区别：</p>
<ul>
<li>内存的申请方式不同：前者需程序员自己申请，因此也需指明变量大小；后者由系统自动分配。</li>
<li>系统响应的不同<br>对于栈，当栈的剩余空间大于所申请的空间，系统会为程序提供内存，否则提示栈溢出。<br>对于堆，系统收到申请空间的请求后会变量一个记录内存空闲地址的链表，找到一个空间大于所申请空间的堆结点时，就将该节点从接了内存空闲地址的链表中删除，并将该结点的内存分配给程序。然后在这块区域的首地址处记录分配的大小，这样使用free函数，delete(C++ )函数释放内存时，函数才能正确识别并删除该内存区域的所有变量。另外，所申请的内存空间与堆结点上的内存空间不一定相等，系统会自动将堆节点上多出的那一部分内存空间回收到空闲链表中。</li>
<li>空间大小的不同<br>栈是一块连续的内存区域，它的大小是2M，也有的说是1M，总之是一个编译时就确定的常数，是由系统预先根据栈顶的地址和栈的最大容量定义好的。<br>堆是不连续的内存区域，各块区域由链表将它们串联起来，它的上限是由系统中的有效虚拟内存来定的，因此获得的空间较大，获得方式也较灵活。</li>
<li>执行效率的不同<br>栈由系统自动分配，因此速度较快，但是程序员不能对其进行操作。<br>堆是由程序员分配的内存，一般速度较慢，而且容易产生碎片，不过用起来很方便。</li>
<li>执行函数时的不同<br>栈：先进后出原则<br>堆：效率比栈低的多，也容易产生碎片，好处是可以存储相当大的数据，并且一些细节也可以由程序员来安排 </li>
</ul>
</blockquote>
<ol>
<li>内存泄露<br>简单的说就是申请了一块内存空间使用完毕后没有释放，表现为随着程序运行时间越长，占用内存越多，最终用尽全部内存，整个系统崩溃。由程序申请的一块内存，没有任何一个指针指向它，那么这块内存就泄露了。</li>
</ol>
<h3 id="五．-指针与数组"><a href="#五．-指针与数组" class="headerlink" title="五． 指针与数组"></a>五． 指针与数组</h3><ol>
<li>用指针操作数组</li>
<li>字符串：<br><code>strcat(连接)，strlen(长度)，strcpy(拷贝)，strcmp(比较大小，相等返回0，不相等返回-1)</code></li>
<li>命令行参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">在main函数的参数列表中可以写入形参：</div><div class="line">Int main(int argc, char *argv[])</div><div class="line">&#123; </div><div class="line">int i; </div><div class="line">printf(“argc:d%\n,argc”);//以空格为单位分割</div><div class="line">printf(“s%\n”,argv[0]”);//输出命令本身</div><div class="line">for(i=1;i&lt;argc;i++)&#123;</div><div class="line">printf(“s%\n”,argv[i]”);//把输入的命令行参数打印出来</div><div class="line">&#125;</div><div class="line">return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="六．-预处理与VT码（在未用windows界面早期使用命令时使用VT码）"><a href="#六．-预处理与VT码（在未用windows界面早期使用命令时使用VT码）" class="headerlink" title="六． 预处理与VT码（在未用windows界面早期使用命令时使用VT码）"></a>六． 预处理与VT码（在未用windows界面早期使用命令时使用VT码）</h3><ol>
<li>#include 指令<br><code>#include “file.h”  #include &lt;file.h&gt;</code><br>“ ”：编译器从用户的工作路径开始搜索(当前目录找不到会到系统库查找)<br>&lt;&gt;：编译器从标准库路径开始搜索<br>导入.h文件：是为了建立文件之间的联系，.h文件只是存放函数声明，比较小。</li>
<li>条件编译<br><code>#if,  #else,  #endif,  #ifdef,  #ifndef,  #undef(取消宏定义)</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eg1. 多行注释：</div><div class="line">#if  0/1（不显示/显示）</div><div class="line">...</div><div class="line">#endif</div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eg2.宏替换</div><div class="line">#define OFF 0/1</div><div class="line">...</div><div class="line">OFF</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">eg3.</div><div class="line">#ifndef  _HHHH_H</div><div class="line">#define  _HHHH_H</div><div class="line">...</div><div class="line">#endif</div><div class="line">//以上代码防止头文件被重复引用 </div><div class="line">``` </div><div class="line">3. 宏替换（#define 标识符（即符号常量） 字符串）//宏替换有问题，因运而生内联函数</div><div class="line"> </div><div class="line">&gt; `★typedef 关键字【重新定义(数据类型)（eg.  UINT x ; //无符号整形 PINT p;//整形的指针）】`</div><div class="line"></div><div class="line">&gt;注：typeof还可以重新定义结构体（例如结构体嵌套中使用它重新命名结构体）或枚举等:</div><div class="line">`eg. Typeof struct date_st DATE或tepeof struct date_st&#123;...&#125;DATE;`</div><div class="line"> </div><div class="line">&gt; ★#define 定义swap(A,B)：</div><div class="line">1） `&#123;int temp=a; a=b; b=temp;&#125;`</div><div class="line">这种方法最常见，也是最不容易出错的。</div><div class="line">2）`&#123;a = a+b; b = a-b; a = a-b;&#125;`</div><div class="line">这种方法少了一个中间变量，缺点是有可能溢出。</div><div class="line">3）`&#123;a ^= b; b^= a; a ^= b; &#125;`</div><div class="line">这种位运算方法速度快也不需第三个变量。</div><div class="line"> </div><div class="line">&gt; ★补充：#号(双引号)和##号（连接字符串）的用法：</div></pre></td></tr></table></figure>
<p>eg. define str(s1,s2)  #s2#s2<br>//以字符串形式（加” ”）输出”s1””s2” ，如果s1,s2是string类型则直接输出。</p>
<p>#define slink(s1,s2)  s1##s2 //s1,s2不能加” ”<br>【#define link(s1,s2) s1 s2 //s1,s2加” ”】<br>//无论s1,s2是字符还是int，##只是将s1,s2进行连接。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">### 七． C语言模块编程</div><div class="line"> </div><div class="line">拆分文件，以多个文件编写C语言程序（头部引入头文件）。</div><div class="line"> `eg:   *.c   *.h   main.c`</div><div class="line"> </div><div class="line"> </div><div class="line">### 八． 静态链接库与动态链接库</div></pre></td></tr></table></figure></p>
<p>//存放函数库的常用目录 /lib  /usr/lib<br>//静态链接库：对函数库的链接是放在编译时期完成的，对象文件（.o）与牵涉到的函数库被拷贝到一个执行文件，通常文件名为libxx.a （xx(库名)）<br>//.so结尾的是动态链接库，.a结尾的是静态链接库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">### 九． 指针的高级应用</div><div class="line">1.指针变量赋值问题</div></pre></td></tr></table></figure></p>
<p>int <em>a;<br>int </em>b;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; ★将指针b赋值给指针a，即a=b，之前要释放指针a所指向的内存空间，否则a的内存空间不再被访问，造成内存丢失。</div><div class="line">&gt; ★C语言规定指针只能指向类型相同的变量，指向不同类型变量的时候一定要进行强制类型转换。</div><div class="line"> </div><div class="line">2.指针用于数组</div><div class="line">* 数组名与指针变量的区别：数组名是一个地址常量，数组名是不能改变的，而指针是一个变量，操作数组中的元素可以用指针实现。</div><div class="line">&gt; 指针越界错误（段错误：不再访问范围内）</div><div class="line">* 数组与指针的区别：当用指针存储字符串的时候，字符串存储在静态存储区，此时字符串不能用指针修改。`eg.  Char *s=”Hello World”;`</div><div class="line"></div><div class="line">3.二级指针（指向指针的指针）</div><div class="line"></div><div class="line">&gt; 二级指针的值传递与指针传递。</div></pre></td></tr></table></figure></p>
<p>eg.</p>
<p>#include <stdio.h></stdio.h></p>
<p>#include<stdlib.h><br>void init(int <em>*p){
</em>p=malloc(4);<br>}<br>int mian(){<br>int <em>p=NULL;<br>init(&amp;p)
</em>p=100<br>printf(“d%\n,*p”);<br>free(p);<br>retrun 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">4.多级指针</div><div class="line"></div><div class="line">5.函数指针（基本上作函数的参数）【可用来实现C语言接口】</div></pre></td></tr></table></figure></stdlib.h></p>
<p>eg. </p>
<p>#include<stdio.h><br>int add(int a,int b){<br>return a+b;<br>}<br>int main(){<br>int(*cal)(int,int);//函数指针<br>cal = add;//将函数指针指向add函数<br>printf(“d%\n”,cal(1,2));<br>return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">### 十． 组合数据类型</div><div class="line">1. 结构体类型</div><div class="line">+ 结构体定义：不同数据类型的变量的集合。</div><div class="line"></div><div class="line">&gt; 结构体就是C语句，结束必须加分号。结构体内，字符数组成员赋值用strcpy()。</div></pre></td></tr></table></figure></stdio.h></p>
<p>eg.<br>struct(结构体) student(类型名){…}; //结构体声明<br>struct(结构体) student(类型名) stu(变量名);  //结构体使用<br>注：可在结构体声明时就定义一个结构体变量,可写在{…}前或{…}后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+ 结构体数组的使用跟普通数组一样。</div><div class="line">`eg.struct student stu[50]`</div><div class="line"> </div><div class="line">+ ★访问结构体成员：</div><div class="line">结构体变量名.成员名  </div><div class="line">结构体指针变量-&gt;成员名</div><div class="line"></div><div class="line">&gt; 注：第一种是栈中变量定义的结构体，第二种放在堆里面，是使用剩余内存来开辟（molloc）的空间【结构体申请空间要在main()中】。如果结构体很大，里面涉及变量很多时用第二种方式。</div><div class="line"> </div><div class="line">+ 结构体的嵌套</div><div class="line"> </div><div class="line">+ 结构体中，char类型由占用一个字节变为4个字节【与前边对齐】。</div><div class="line">在结构体结尾加上 __attribute__((packed))【不自动对齐】。</div></pre></td></tr></table></figure></p>
<p>eg. #include<stdio.h><br>sturct a_st{<br>char ch;<br>int i;<br>}attribute__((packed));//不自动对齐</stdio.h></p>
<p>int main(){<br>struct a_st A[10000];//如果自动对齐，声明此数组将会浪费很多空间<br>printf(“d%\n”,sizeof(stuct a_st));<br>return 0;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+ 将结构体定义为指针类型</div><div class="line">©用指针操作数组或字符串的时候，不能用sizeof()计算字符串或数组的长度，应为指针的大小是固定的。 </div><div class="line"> </div><div class="line">&gt; 补充：★class与struct的区别:</div><div class="line">&gt; * `【structs过渡到class，C++是C的升级版。C语言的编译器gcc不支持class关键字，所以可用c++或g++编译。gcc也可以编译.cpp(c++)文件，但要求该.cpp文件格式是C的格式，调用库要用C语言的库去调用而不能用C++的库去调用】`</div><div class="line">&gt; * `【eg.C++由很多特性：(源程序文件头部有:#include&lt;iostream&gt;,using namespace std;)；(结构体使用时不用写stuct)；(C++输出count&lt;&lt;..&lt;&lt;..&lt;&lt;endl;)；等等】`</div><div class="line">&gt; * `C语言编译器gcc最新版本支持在结构体里写函数，先前早期版本不行。` </div><div class="line">&gt; * `★用stuct(结构体)，里面的成员属性和函数都是公共的，谁都能访问。而用class，要加修饰符，默认的是private：将它改成public:即可。`</div><div class="line"></div><div class="line">2. 枚举类型（经常作为函数 返回值 ）</div></pre></td></tr></table></figure></p>
<p>eg.<br>enum bool{false,ture}; //java中的ture和false就是通过枚举定义的<br>enum bool isNum(int n){…}</p>
<p>typedef enum status STATUS; //用typedef重定义（重命名）<br>enum status{FAIL=-1,NOLINK,ONLINK};//可以自己约定开始的值<br>STATUS isAction(){…}</p>
<p>int main(){<br>// enum bool b;<br>prinft(“d%\n”,false);//输出结果为0<br>prinft(“d%\n”,FAIL);//输出结果为-1<br>prinft(“d%\n”,ONLINK);//输出结果为1，则中间是0<br>}</p>
<blockquote>
<p>以上enum（枚举）类似宏（#define False 0）,但是宏返回的是 int类型，而enum返回的是boolean类型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">3.类型定义 typedef</div><div class="line"></div><div class="line">4.联合(union)</div><div class="line"></div><div class="line">&gt; 定义：将几个基本数据类型组合在一起（所有数据类型的空间都是在一起的）。</div><div class="line">网络编程中使用广泛。</div><div class="line"> </div><div class="line">&gt; ©位域（由于内存空间的发展，已经被淘汰了）： </div><div class="line">￭位域只存储在char类型和int类型</div><div class="line">￭位域就是按位分配内存的结构体</div><div class="line">￭位域不能跨段（一段位域不能跨两个字节）</div><div class="line">￭不支持数组位域</div><div class="line"></div><div class="line"></div><div class="line">### 十一． vin的使用</div><div class="line"></div><div class="line">&gt; a：在光标后追加   A：在一行后追加    i：在光标钱面插入  I：在一行前面插入</div><div class="line">s: 删除当前光标后插入  S: 删除整行后插入   o: 另起一行插入  O：在当前行上面插入</div><div class="line">yy: 复制当前行  pp：粘贴当前行在光标的下一行  dd: 剪切当前行  u:撤销</div><div class="line">nyy: 多行复制(n表示数字，从光标的位置开始向下复制n行)</div><div class="line">ngg: 定位(n表示数字)  gg：调到文件开头   GG：跳到文件的最后一行</div><div class="line">查找：在正常模式下输入 / 所要查找的单词；next n：向下查找，N:向上查找</div><div class="line">替换：（%表示整个文件，也可用具体行号范围如：0，40）%s/要查找的字符/要替换的字符</div><div class="line">添加注释：（开头如上用具体行号）s/^/\/\/(^表示文件的开头，\位转义字符)</div><div class="line">去掉注释：开头如上用具体行号）s/^\/\/(^表示文件的开头，\位转义字符)</div><div class="line">自动补全：ctrl+p</div><div class="line">查看多个源程序：vim 文件名1 文件名2 -o(小写o为上下屏,大写O为左右屏)</div><div class="line">退出多个源程序: :qa   切屏：按两下ctrl+w  </div><div class="line">找到头部引入文件：:sp(split ) 文件名  或者：vs(vsplit) 文件名</div><div class="line"></div><div class="line"></div><div class="line">### 十二． gcc与gdb的使用</div><div class="line"></div><div class="line">&gt; 版本：gcc -v  帮助：gcc  - -help  查手册：man 参数 ...</div><div class="line">&gt; + 预处理：gcc  -E 文件名(.c) -o 文件名(.i)</div><div class="line">&gt; + 汇编：gcc  -S 文件名(.i)  -o 文件名(.s)(不写则默认生成.s文件)</div><div class="line">&gt; + 编译：gcc  -c  文件名(.s)  -o 文件名(.o)(不写则默认生成.o文件)</div><div class="line">&gt; &gt; 注：vim生成的是文本文件，将.o文件转换成二进制文件：%!xxd ，返回原样: %!xxd -r </div><div class="line">&gt; + 连接：gcc test.o -o test 可以直接执行第四步跳过前面3步</div><div class="line">&gt; + gcc其它参数：</div><div class="line">-g: 添加程序的调试信息，然后可以使用GDB调试程序 (-&gt;gdb  a.out)</div><div class="line">`eg. Start: 单步执行(-&gt;s)   run: 执行完   bt: 查看栈，看有多少函数执行  n: 执行下一步`</div><div class="line"> </div><div class="line">### 十三． ubuntu下的DDD调试工具的使用</div><div class="line">用法和gdb一样，只是在gdb的基础上实现了可视化界面</div><div class="line"> </div><div class="line">### 十四． 文件操作</div><div class="line">&gt; ＊C语言对文件的操作分为两种方式，即流式文件操作和I/O文件操作（前者调用标准库实现。后者调用内核函数库实现,在linux操作系统中，通过其提供的底层接口实现）</div><div class="line"></div><div class="line">1. 流式文件操作</div></pre></td></tr></table></figure></p>
</blockquote>
<p>1)  fopen()<br>fopen 的原型是：FILE <em>fopen（const char </em>filename, const char *mode）,<br>fopen实现三个功能：为使用而打开一个流；把一个文件和此流相连接；给此流返回一个FILE指针参数；filename指向要打开的文件名，mode表示打开状态的字符串，其取值如下表：<br>“r” ：  以只读方式打开文件<br>“r+”：  以读/写方式打开文件，如无文件则出错<br>“w”：  以只写方式打开文件（并清空文件内容）<br>“w+”： 以读/写方式打开文件，如无文件则生成新文件<br>“a”：  以追加方式打开只写文件，（文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留，如无文件则生成新文件）<br>“a+”： 以追加方式打开读/写文件，同上<br>FILE这个结构包含了文件操作的基本属性，对文件的操作都要通过这个结构的指针来进行，此种文件操作常用的函数及功能如下：<br>fgetc()：从流中读取一个字符<br>fgets()：从流中读一行或指定个字符<br>fputc(): 写一个字符到流中<br>fputs(): 写字符串到流<br>fseek(): 在流中定位到指定的字符（移动文件中的指针）<br>rewind(): 复位文件定位器到文件开始处<br>ftell(): 读取字节数<br>fread(): 从流中读指定个数的字符<br>fwrite(): 向流中写指定个数的字符<br>fprintf(): 按格式输入到流<br>ferror(): 发生错误时返回其值<br>feof(): 到达文件尾时返回真值<br>…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">&gt; ★fgets()</div><div class="line">函数功能：用于从文件流中读取一行或指定个数的字符。</div><div class="line">原型：char * fgets(char * string, int size, FILE * stream);</div><div class="line">参数说明：</div><div class="line">&gt; + string为一个字符数组，用来保存读取到的字符。</div><div class="line">&gt; + size为要读取的字符的个数。如果该行字符数大于size-1，则读到 size-1 个字符时结束，并在最后补充&apos; \0&apos;；如果该行字符数小于等于 size-1，则读取所有字符，并在最后补充 &apos;\0&apos;。即，每次最多读取 size-1 个字符。</div><div class="line">&gt; + (3)stream为文件流指针。</div><div class="line">&gt; &gt; 【返回值】：读取成功，返回读取到的字符串，即string；失败或读到文件结尾返回NULL。因此我们不能直接通过fgets()的返回值来判断函数是否是出错而终止的，应该借助feof()函数或者ferror()函数来判断。</div><div class="line">&gt; &gt; &gt; 注意：fgets()与gets()不一样，不仅仅是因为gets()函数只有一个参数 FILE *stream，更重要的是，fgets()可以指定最大读取的字符串的个数，杜绝了gets()使用不当造成缓存溢出的问题。</div><div class="line"></div><div class="line">&gt; ★fread和fwrite </div><div class="line"> 函数功能：用来读写一个数据块。 </div><div class="line">一般调用形式：fread(buffer,size,count,fp);  fwrite(buffer,size,count,fp); </div><div class="line">参数说明：</div><div class="line">&gt; + buffer：是一个指针，对fread来说，它是读入数据的存放地址。对fwrite来说，是要输出数据的地址。 </div><div class="line">&gt; + size：要读写的字节数； </div><div class="line">&gt; + count：要进行读写多少个(次)size字节的数据项； </div><div class="line">&gt; + fp：文件流指针。 </div><div class="line">&gt; &gt; 注意：1 完成读写(fwrite())操作后必须关闭流(fclose())。</div><div class="line"></div><div class="line">&gt; ★fprintf()：按格式输入到流，其原型是int fprintf(FILE *stream, const char *format[, argument, ...]);其用法和printf()相同，不过不是写到控制台，而是写到流罢了。</div><div class="line"></div><div class="line">&gt; ★fseek()</div><div class="line">函数功能：用来移动文件流的读写位置.</div><div class="line">头文件：#include &lt;stdio.h&gt;</div><div class="line">定义函数：int fseek(FILE * stream, long offset, int whence);</div><div class="line">参数说明：</div><div class="line">&gt; + 参数stream为已打开的文件指针,</div><div class="line">&gt; + 参数offset为根据参数whence来移动读写位置的位移数。</div><div class="line">&gt; + 参数whence 为下列其中一种:</div><div class="line">SEEK_SET 从距文件开头offset位移量为新的读写位置. </div><div class="line">SEEK_CUR 以目前的读写位置往后增加offset个位移量.</div><div class="line">SEEK_END 将读写位置指向文件尾后再增加offset 个位移量. </div><div class="line">当whence 值为SEEK_CUR 或SEEK_END 时, 参数offset 允许负值的出现.</div><div class="line">&gt; &gt; 下列是较特别的使用方式：</div><div class="line">&gt; &gt; + 欲将读写位置移动到文件开头时:fseek(FILE *stream, 0, SEEK_SET);</div><div class="line">&gt; &gt; + 欲将读写位置移动到文件尾时:fseek(FILE *stream, 0, 0SEEK_END);</div><div class="line">&gt; &gt; &gt; + 返回值：当调用成功时则返回0, 若有错误则返回-1, errno 会存放错误代码.</div><div class="line">&gt; &gt; &gt; + 附注：fseek()不像lseek()会返回读写位置, 必须用ftell()取得目前读写的位置。</div></pre></td></tr></table></figure></p>
<p>eg.<br>创建文件1.text （内容：ABC）<br>读取文件：<br>eg1. </p>
<p>#include<stdio.h><br>int main(){<br>FILE *fp = fopen(“1.tex”,” r”);  //r表示以只读方式打开文件1.text<br>char c = fgetc(fp);<br>printf(“c%\n”,c); //读取A<br>printf(“c%\n”,fgetc(fp));//第一次读取后指针往后移一位，则第二次读取B，同理第三次读取C，而第四次将输出空格<br>fclose(fp);<br>return 0;<br>}<br>注：可用循环结构实现上述打印<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">eg2. </div><div class="line">#include&lt;stdio.h&gt; </div><div class="line">#include&lt;stdlib.h&gt;</div><div class="line">#include&lt;string.h&gt; </div><div class="line">int main()&#123;</div><div class="line">FILE *fp = fopen(“1.tex”,” r”);  </div><div class="line">char *p = molloc(100);</div><div class="line">memcpy(p,”\0”,100); //此处不能用strcpy(p,0)，”\0”在此表示填充</div><div class="line">fgets(p,4,fp);//4表示读取的字节数（计算机最小单位是字节而不是位）</div><div class="line">printf(“s%\n”,p);</div><div class="line">putchar(‘\n’); //去掉空格（按原格式读取）</div><div class="line">free(p);</div><div class="line">fclose(fp);</div><div class="line">feturn 0; </div><div class="line">&#125;</div><div class="line">``` </div><div class="line">&gt;&gt; 补充：★strcpy和memcpy</div><div class="line">&gt;&gt; * strcpy和memcpy都是标准C库函数，它们有下面的特点：</div><div class="line">strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容，还会复制字符串的结束符。【已知strcpy函数的原型是：char* strcpy(char* dest, const char* src);】</div><div class="line">memcpy提供了内存地址的复制。即memcpy对于需要复制的内容没有限制，因此用途更广。</div><div class="line">&gt;&gt; * strcpy和memcpy主要有以下3方面的区别：</div><div class="line">1）复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</div><div class="line">2）复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符&quot;\0&quot;才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</div><div class="line">3）用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。</div><div class="line"></div><div class="line">``` </div><div class="line">eg3. </div><div class="line">#include&lt;stdio.h&gt; </div><div class="line">int main(int argc , ch ar*argv[ ])&#123;</div><div class="line">FILE *fp = NULL;</div><div class="line">int size = 0;</div><div class="line">if(argc &lt; 2)&#123;</div><div class="line">return 1;</div><div class="line">&#125;</div><div class="line">fp = fopen(argv[1] ,” r”);  //命令行读取第一个参数 </div><div class="line">fseek(fp, 0 , SEEK_END); //把fp从开头移动到结尾</div><div class="line">size = ftell(fp); //ftell()表示读取字节数</div><div class="line">printf(“file size:d%\n”, size);</div><div class="line">fclose(fp);</div><div class="line">feturn 0;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></stdio.h></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">eg4. </div><div class="line">#include&lt;stdio.h&gt; </div><div class="line">int main(int argc , char*argv[ ])&#123;</div><div class="line">int size = 0;</div><div class="line">FILE *fp = NULL;</div><div class="line">char *str = NULL;</div><div class="line">fp = fopen(argv[1] ,” r”);  //命令行读取第一个参数 </div><div class="line">If(fp == NULL)&#123; //做判断，如果文件不存在就退出</div><div class="line">perror(“error”);</div><div class="line">retrun 1;</div><div class="line">&#125;</div><div class="line">//perror( ) 用来将上一个函数发生错误的原因输出到标准设备(stderr)。（不可以丢了#include&lt;stdio.h&gt;这个头文件，perror是包含在这个文件里的）</div><div class="line">fseek(fp, 0 , SEEK_END); //把fp从开头移动到结尾（0—SEEK_END）</div><div class="line">size = ftell(fp); //ftell()表示读取字节数</div><div class="line">rewind(fp);//复位指针</div><div class="line">str = malloc(size+1); //size+1: 包括”\n”</div><div class="line">memcpy(str , “0” , size+1)；//第二个参数是个地址</div><div class="line">fread(str , size , 1 , fp); //数字1表示读1次</div><div class="line">str[size]=’\0’; //读完后将其终止</div><div class="line">printf(“s%\n”, str);</div><div class="line">fclose(fp);</div><div class="line">Free(str); </div><div class="line">feturn 0;  </div><div class="line">&#125;</div><div class="line">``` </div><div class="line"></div><div class="line">### 十五．const_extern_static修饰符详解</div><div class="line">1. extern称为外部变量。为了使变量除了在定义它的源文件中可以使用外，还要被其它文件使用，因此，必须将全程变量通知每一个程序模块文件，此时可用extern说明。</div><div class="line">2. .c文件中static修饰的变量或方法只限制在本文件里访问，加extern关键字也访问不了。</div><div class="line">3. 不要在头文件(.h)文件中用static关键字修饰变量或方法（基本上关键字都写在实现文件(.c)里面）。</div><div class="line"></div><div class="line">### 十六．动态数组</div><div class="line"></div><div class="line">### 十七．Makefile的使用</div></pre></td></tr></table></figure>
<p>创建test.c文件<br>eg . 编写Makefile文件：<br>all:test //目标条件<br>test:test.o //依赖(.o)文件, ：表示依赖关系<br>  gcc test.o -o test<br>test.o:test.s<br>  gcc -c test.s -o test.o<br>test.s:test.i<br>  gcc -S test.i -o test.s -std=c99<br>test.i:test.c<br>  gcc -E test.c -o test.i<br>执行：make all<br>clean: //处理（删除）命令<br>rm -rf  <em>.i  </em>.o  *.s<br>执行：make clean (不写clean，默认是执行第一个all)<br>直接生成汇编：make test.s<br>（可用变量替换的方式）修改程序：<br>TARGET=test<br>OBJ=test.o<br>All:$(TARGET)<br>$(TARGET):test.o<br>gcc test.o -o test //可写成：gcc $^ -o $@,$^指代依赖文件(test.o ) ,S@指代目标文件($(TARGET))<br>…</p>
<p>也可跳过预处理和汇编：（注释语句用#）<br>TARGET=test<br>All:$(TARGET)<br>$(TARGET):$(OBJ)<br>  gcc $^ -o $@,$^<br>test.i:test.c //可用%代替test,写成%.i : %.c，%代表当前文件，此外<em>代表当前文件夹<br>  gcc -c test.c -o test.o //同上可写成：gcc -c $^ -o $@<br>clean:<br>rm -rf  </em>.i  <em>.o  </em>.s<br>.PHONY:$(TARGET)   all   //不管程序代码是不是最新的（有没有变动）都从新编译<br>```</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://pan.baidu.com/s/1jIfiwwY"
               alt="sgt_tiger" />
          <p class="site-author-name" itemprop="name">sgt_tiger</p>
          <p class="site-description motion-element" itemprop="description">技术 | 生活</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">7</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">7</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">sgt_tiger</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  




  
  

  

  

  

</body>
</html>
